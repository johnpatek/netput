// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: netput.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(fa4a1bc90f7e051b);
CAPNP_DECLARE_SCHEMA(afebe44d7bd999ac);
CAPNP_DECLARE_SCHEMA(cde28ab20dab3120);
CAPNP_DECLARE_SCHEMA(b0e01c3b79eba209);
CAPNP_DECLARE_SCHEMA(91053e416163d71e);
CAPNP_DECLARE_SCHEMA(f1c4f972666019a7);
CAPNP_DECLARE_SCHEMA(b2ed5d8c33a99cfc);
CAPNP_DECLARE_SCHEMA(e8db608ad47956cb);
CAPNP_DECLARE_SCHEMA(ba96fd62444bda33);
CAPNP_DECLARE_SCHEMA(a542553ee6cb6157);
CAPNP_DECLARE_SCHEMA(977d693f820bb9cd);
CAPNP_DECLARE_SCHEMA(f0473f0015c4a21b);
CAPNP_DECLARE_SCHEMA(fef3ce052a733f88);
CAPNP_DECLARE_SCHEMA(cdd23f44c925b297);
enum class InputState_cdd23f44c925b297: uint16_t {
  RELEASED,
  PRESSED,
};
CAPNP_DECLARE_ENUM(InputState, cdd23f44c925b297);
CAPNP_DECLARE_SCHEMA(83b374bc3dd69907);
enum class MouseButton_83b374bc3dd69907: uint16_t {
  LEFT,
  MIDDLE,
  RIGHT,
  X1,
  X2,
};
CAPNP_DECLARE_ENUM(MouseButton, 83b374bc3dd69907);
CAPNP_DECLARE_SCHEMA(aae0ea937045b314);
enum class WindowEventType_aae0ea937045b314: uint16_t {
  SHOWN_TYPE,
  HIDDEN_TYPE,
  EXPOSED_TYPE,
  MOVED_TYPE,
  RESIZED_TYPE,
  MINIMIZED_TYPE,
  MAXIMIZED_TYPE,
  RESTORED_TYPE,
  MOUSE_ENTER_TYPE,
  MOUSE_LEAVE_TYPE,
  FOCUS_GAINED_TYPE,
  FOCUS_LOST_TYPE,
};
CAPNP_DECLARE_ENUM(WindowEventType, aae0ea937045b314);
CAPNP_DECLARE_SCHEMA(95e9db4de2703d30);
CAPNP_DECLARE_SCHEMA(dbb615788c241744);
CAPNP_DECLARE_SCHEMA(db2ad99c88a32a89);
CAPNP_DECLARE_SCHEMA(b0c8141849eedc89);
CAPNP_DECLARE_SCHEMA(e8db2abe6ddec4be);
CAPNP_DECLARE_SCHEMA(93f976fa60566833);

}  // namespace schemas
}  // namespace capnp

namespace netput {
namespace rpc {

struct Netput {
  Netput() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ConnectParams;
  struct ConnectResults;
  struct PushParams;
  struct DisconnectParams;
  struct DisconnectResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(fa4a1bc90f7e051b)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Netput::ConnectParams {
  ConnectParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(afebe44d7bd999ac, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netput::ConnectResults {
  ConnectResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cde28ab20dab3120, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netput::PushParams {
  PushParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b0e01c3b79eba209, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netput::DisconnectParams {
  DisconnectParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(91053e416163d71e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netput::DisconnectResults {
  DisconnectResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f1c4f972666019a7, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ConnectRequest {
  ConnectRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b2ed5d8c33a99cfc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ConnectResponse {
  ConnectResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Message;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8db608ad47956cb, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ConnectResponse::Message {
  Message() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SESSION_ID,
    ERROR,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba96fd62444bda33, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DisconnectRequest {
  DisconnectRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a542553ee6cb6157, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DisconnectResponse {
  DisconnectResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(977d693f820bb9cd, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Event {
  Event() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Info;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f0473f0015c4a21b, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Event::Info {
  Info() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    MOUSE_MOTION,
    MOUSE_BUTTON,
    MOUSE_WHEEL,
    KEYBOARD,
    WINDOW,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fef3ce052a733f88, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::InputState_cdd23f44c925b297 InputState;

typedef ::capnp::schemas::MouseButton_83b374bc3dd69907 MouseButton;

typedef ::capnp::schemas::WindowEventType_aae0ea937045b314 WindowEventType;

struct MouseMotionEvent {
  MouseMotionEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct MouseStateMask;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(95e9db4de2703d30, 4, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MouseMotionEvent::MouseStateMask {
  MouseStateMask() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dbb615788c241744, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MouseButtonEvent {
  MouseButtonEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db2ad99c88a32a89, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MouseWheelEvent {
  MouseWheelEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b0c8141849eedc89, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct KeyboardEvent {
  KeyboardEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8db2abe6ddec4be, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct WindowEvent {
  WindowEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(93f976fa60566833, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Netput::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Netput Calls;
  typedef Netput Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::netput::rpc::Netput::ConnectParams,  ::netput::rpc::Netput::ConnectResults> connectRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::StreamingRequest< ::netput::rpc::Netput::PushParams> pushRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::netput::rpc::Netput::DisconnectParams,  ::netput::rpc::Netput::DisconnectResults> disconnectRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Netput::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Netput Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::netput::rpc::Netput::ConnectParams ConnectParams;
  typedef  ::netput::rpc::Netput::ConnectResults ConnectResults;
  typedef ::capnp::CallContext<ConnectParams, ConnectResults> ConnectContext;
  virtual ::kj::Promise<void> connect(ConnectContext context);
  typedef  ::netput::rpc::Netput::PushParams PushParams;
  typedef ::capnp::StreamingCallContext<PushParams> PushContext;
  virtual ::kj::Promise<void> push(PushContext context);
  typedef  ::netput::rpc::Netput::DisconnectParams DisconnectParams;
  typedef  ::netput::rpc::Netput::DisconnectResults DisconnectResults;
  typedef ::capnp::CallContext<DisconnectParams, DisconnectResults> DisconnectContext;
  virtual ::kj::Promise<void> disconnect(DisconnectContext context);

  inline  ::netput::rpc::Netput::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::netput::rpc::Netput>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Netput::ConnectParams::Reader {
public:
  typedef ConnectParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRequest() const;
  inline  ::netput::rpc::ConnectRequest::Reader getRequest() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netput::ConnectParams::Builder {
public:
  typedef ConnectParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRequest();
  inline  ::netput::rpc::ConnectRequest::Builder getRequest();
  inline void setRequest( ::netput::rpc::ConnectRequest::Reader value);
  inline  ::netput::rpc::ConnectRequest::Builder initRequest();
  inline void adoptRequest(::capnp::Orphan< ::netput::rpc::ConnectRequest>&& value);
  inline ::capnp::Orphan< ::netput::rpc::ConnectRequest> disownRequest();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netput::ConnectParams::Pipeline {
public:
  typedef ConnectParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::netput::rpc::ConnectRequest::Pipeline getRequest();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netput::ConnectResults::Reader {
public:
  typedef ConnectResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResponse() const;
  inline  ::netput::rpc::ConnectResponse::Reader getResponse() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netput::ConnectResults::Builder {
public:
  typedef ConnectResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResponse();
  inline  ::netput::rpc::ConnectResponse::Builder getResponse();
  inline void setResponse( ::netput::rpc::ConnectResponse::Reader value);
  inline  ::netput::rpc::ConnectResponse::Builder initResponse();
  inline void adoptResponse(::capnp::Orphan< ::netput::rpc::ConnectResponse>&& value);
  inline ::capnp::Orphan< ::netput::rpc::ConnectResponse> disownResponse();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netput::ConnectResults::Pipeline {
public:
  typedef ConnectResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::netput::rpc::ConnectResponse::Pipeline getResponse();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netput::PushParams::Reader {
public:
  typedef PushParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEvent() const;
  inline  ::netput::rpc::Event::Reader getEvent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netput::PushParams::Builder {
public:
  typedef PushParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEvent();
  inline  ::netput::rpc::Event::Builder getEvent();
  inline void setEvent( ::netput::rpc::Event::Reader value);
  inline  ::netput::rpc::Event::Builder initEvent();
  inline void adoptEvent(::capnp::Orphan< ::netput::rpc::Event>&& value);
  inline ::capnp::Orphan< ::netput::rpc::Event> disownEvent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netput::PushParams::Pipeline {
public:
  typedef PushParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::netput::rpc::Event::Pipeline getEvent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netput::DisconnectParams::Reader {
public:
  typedef DisconnectParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRequest() const;
  inline  ::netput::rpc::DisconnectRequest::Reader getRequest() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netput::DisconnectParams::Builder {
public:
  typedef DisconnectParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRequest();
  inline  ::netput::rpc::DisconnectRequest::Builder getRequest();
  inline void setRequest( ::netput::rpc::DisconnectRequest::Reader value);
  inline  ::netput::rpc::DisconnectRequest::Builder initRequest();
  inline void adoptRequest(::capnp::Orphan< ::netput::rpc::DisconnectRequest>&& value);
  inline ::capnp::Orphan< ::netput::rpc::DisconnectRequest> disownRequest();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netput::DisconnectParams::Pipeline {
public:
  typedef DisconnectParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::netput::rpc::DisconnectRequest::Pipeline getRequest();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netput::DisconnectResults::Reader {
public:
  typedef DisconnectResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResponse() const;
  inline  ::netput::rpc::DisconnectResponse::Reader getResponse() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netput::DisconnectResults::Builder {
public:
  typedef DisconnectResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResponse();
  inline  ::netput::rpc::DisconnectResponse::Builder getResponse();
  inline void setResponse( ::netput::rpc::DisconnectResponse::Reader value);
  inline  ::netput::rpc::DisconnectResponse::Builder initResponse();
  inline void adoptResponse(::capnp::Orphan< ::netput::rpc::DisconnectResponse>&& value);
  inline ::capnp::Orphan< ::netput::rpc::DisconnectResponse> disownResponse();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netput::DisconnectResults::Pipeline {
public:
  typedef DisconnectResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::netput::rpc::DisconnectResponse::Pipeline getResponse();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ConnectRequest::Reader {
public:
  typedef ConnectRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasUserData() const;
  inline  ::capnp::Data::Reader getUserData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ConnectRequest::Builder {
public:
  typedef ConnectRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUserData();
  inline  ::capnp::Data::Builder getUserData();
  inline void setUserData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initUserData(unsigned int size);
  inline void adoptUserData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownUserData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ConnectRequest::Pipeline {
public:
  typedef ConnectRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ConnectResponse::Reader {
public:
  typedef ConnectResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Message::Reader getMessage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ConnectResponse::Builder {
public:
  typedef ConnectResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Message::Builder getMessage();
  inline typename Message::Builder initMessage();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ConnectResponse::Pipeline {
public:
  typedef ConnectResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Message::Pipeline getMessage();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ConnectResponse::Message::Reader {
public:
  typedef Message Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isSessionId() const;
  inline bool hasSessionId() const;
  inline  ::capnp::Text::Reader getSessionId() const;

  inline bool isError() const;
  inline bool hasError() const;
  inline  ::capnp::Text::Reader getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ConnectResponse::Message::Builder {
public:
  typedef Message Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isSessionId();
  inline bool hasSessionId();
  inline  ::capnp::Text::Builder getSessionId();
  inline void setSessionId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSessionId(unsigned int size);
  inline void adoptSessionId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSessionId();

  inline bool isError();
  inline bool hasError();
  inline  ::capnp::Text::Builder getError();
  inline void setError( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initError(unsigned int size);
  inline void adoptError(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ConnectResponse::Message::Pipeline {
public:
  typedef Message Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DisconnectRequest::Reader {
public:
  typedef DisconnectRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSessionId() const;
  inline  ::capnp::Text::Reader getSessionId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DisconnectRequest::Builder {
public:
  typedef DisconnectRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSessionId();
  inline  ::capnp::Text::Builder getSessionId();
  inline void setSessionId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSessionId(unsigned int size);
  inline void adoptSessionId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSessionId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DisconnectRequest::Pipeline {
public:
  typedef DisconnectRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DisconnectResponse::Reader {
public:
  typedef DisconnectResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasError() const;
  inline  ::capnp::Text::Reader getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DisconnectResponse::Builder {
public:
  typedef DisconnectResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasError();
  inline  ::capnp::Text::Builder getError();
  inline void setError( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initError(unsigned int size);
  inline void adoptError(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DisconnectResponse::Pipeline {
public:
  typedef DisconnectResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Event::Reader {
public:
  typedef Event Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSessionId() const;
  inline  ::capnp::Text::Reader getSessionId() const;

  inline typename Info::Reader getInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Event::Builder {
public:
  typedef Event Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSessionId();
  inline  ::capnp::Text::Builder getSessionId();
  inline void setSessionId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSessionId(unsigned int size);
  inline void adoptSessionId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSessionId();

  inline typename Info::Builder getInfo();
  inline typename Info::Builder initInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Event::Pipeline {
public:
  typedef Event Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Info::Pipeline getInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Event::Info::Reader {
public:
  typedef Info Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isMouseMotion() const;
  inline bool hasMouseMotion() const;
  inline  ::netput::rpc::MouseMotionEvent::Reader getMouseMotion() const;

  inline bool isMouseButton() const;
  inline bool hasMouseButton() const;
  inline  ::netput::rpc::MouseButtonEvent::Reader getMouseButton() const;

  inline bool isMouseWheel() const;
  inline bool hasMouseWheel() const;
  inline  ::netput::rpc::MouseWheelEvent::Reader getMouseWheel() const;

  inline bool isKeyboard() const;
  inline bool hasKeyboard() const;
  inline  ::netput::rpc::KeyboardEvent::Reader getKeyboard() const;

  inline bool isWindow() const;
  inline bool hasWindow() const;
  inline  ::netput::rpc::WindowEvent::Reader getWindow() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Event::Info::Builder {
public:
  typedef Info Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isMouseMotion();
  inline bool hasMouseMotion();
  inline  ::netput::rpc::MouseMotionEvent::Builder getMouseMotion();
  inline void setMouseMotion( ::netput::rpc::MouseMotionEvent::Reader value);
  inline  ::netput::rpc::MouseMotionEvent::Builder initMouseMotion();
  inline void adoptMouseMotion(::capnp::Orphan< ::netput::rpc::MouseMotionEvent>&& value);
  inline ::capnp::Orphan< ::netput::rpc::MouseMotionEvent> disownMouseMotion();

  inline bool isMouseButton();
  inline bool hasMouseButton();
  inline  ::netput::rpc::MouseButtonEvent::Builder getMouseButton();
  inline void setMouseButton( ::netput::rpc::MouseButtonEvent::Reader value);
  inline  ::netput::rpc::MouseButtonEvent::Builder initMouseButton();
  inline void adoptMouseButton(::capnp::Orphan< ::netput::rpc::MouseButtonEvent>&& value);
  inline ::capnp::Orphan< ::netput::rpc::MouseButtonEvent> disownMouseButton();

  inline bool isMouseWheel();
  inline bool hasMouseWheel();
  inline  ::netput::rpc::MouseWheelEvent::Builder getMouseWheel();
  inline void setMouseWheel( ::netput::rpc::MouseWheelEvent::Reader value);
  inline  ::netput::rpc::MouseWheelEvent::Builder initMouseWheel();
  inline void adoptMouseWheel(::capnp::Orphan< ::netput::rpc::MouseWheelEvent>&& value);
  inline ::capnp::Orphan< ::netput::rpc::MouseWheelEvent> disownMouseWheel();

  inline bool isKeyboard();
  inline bool hasKeyboard();
  inline  ::netput::rpc::KeyboardEvent::Builder getKeyboard();
  inline void setKeyboard( ::netput::rpc::KeyboardEvent::Reader value);
  inline  ::netput::rpc::KeyboardEvent::Builder initKeyboard();
  inline void adoptKeyboard(::capnp::Orphan< ::netput::rpc::KeyboardEvent>&& value);
  inline ::capnp::Orphan< ::netput::rpc::KeyboardEvent> disownKeyboard();

  inline bool isWindow();
  inline bool hasWindow();
  inline  ::netput::rpc::WindowEvent::Builder getWindow();
  inline void setWindow( ::netput::rpc::WindowEvent::Reader value);
  inline  ::netput::rpc::WindowEvent::Builder initWindow();
  inline void adoptWindow(::capnp::Orphan< ::netput::rpc::WindowEvent>&& value);
  inline ::capnp::Orphan< ::netput::rpc::WindowEvent> disownWindow();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Event::Info::Pipeline {
public:
  typedef Info Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MouseMotionEvent::Reader {
public:
  typedef MouseMotionEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint32_t getWindowId() const;

  inline bool hasStateMask() const;
  inline  ::netput::rpc::MouseMotionEvent::MouseStateMask::Reader getStateMask() const;

  inline  ::int32_t getX() const;

  inline  ::int32_t getY() const;

  inline  ::int32_t getRelativeX() const;

  inline  ::int32_t getRelativeY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MouseMotionEvent::Builder {
public:
  typedef MouseMotionEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint32_t getWindowId();
  inline void setWindowId( ::uint32_t value);

  inline bool hasStateMask();
  inline  ::netput::rpc::MouseMotionEvent::MouseStateMask::Builder getStateMask();
  inline void setStateMask( ::netput::rpc::MouseMotionEvent::MouseStateMask::Reader value);
  inline  ::netput::rpc::MouseMotionEvent::MouseStateMask::Builder initStateMask();
  inline void adoptStateMask(::capnp::Orphan< ::netput::rpc::MouseMotionEvent::MouseStateMask>&& value);
  inline ::capnp::Orphan< ::netput::rpc::MouseMotionEvent::MouseStateMask> disownStateMask();

  inline  ::int32_t getX();
  inline void setX( ::int32_t value);

  inline  ::int32_t getY();
  inline void setY( ::int32_t value);

  inline  ::int32_t getRelativeX();
  inline void setRelativeX( ::int32_t value);

  inline  ::int32_t getRelativeY();
  inline void setRelativeY( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MouseMotionEvent::Pipeline {
public:
  typedef MouseMotionEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::netput::rpc::MouseMotionEvent::MouseStateMask::Pipeline getStateMask();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MouseMotionEvent::MouseStateMask::Reader {
public:
  typedef MouseStateMask Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::netput::rpc::InputState getLeft() const;

  inline  ::netput::rpc::InputState getMiddle() const;

  inline  ::netput::rpc::InputState getRight() const;

  inline  ::netput::rpc::InputState getX1() const;

  inline  ::netput::rpc::InputState getX2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MouseMotionEvent::MouseStateMask::Builder {
public:
  typedef MouseStateMask Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::netput::rpc::InputState getLeft();
  inline void setLeft( ::netput::rpc::InputState value);

  inline  ::netput::rpc::InputState getMiddle();
  inline void setMiddle( ::netput::rpc::InputState value);

  inline  ::netput::rpc::InputState getRight();
  inline void setRight( ::netput::rpc::InputState value);

  inline  ::netput::rpc::InputState getX1();
  inline void setX1( ::netput::rpc::InputState value);

  inline  ::netput::rpc::InputState getX2();
  inline void setX2( ::netput::rpc::InputState value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MouseMotionEvent::MouseStateMask::Pipeline {
public:
  typedef MouseStateMask Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MouseButtonEvent::Reader {
public:
  typedef MouseButtonEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint32_t getWindowId() const;

  inline  ::netput::rpc::MouseButton getButton() const;

  inline  ::netput::rpc::InputState getState() const;

  inline bool getDouble() const;

  inline  ::int32_t getX() const;

  inline  ::int32_t getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MouseButtonEvent::Builder {
public:
  typedef MouseButtonEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint32_t getWindowId();
  inline void setWindowId( ::uint32_t value);

  inline  ::netput::rpc::MouseButton getButton();
  inline void setButton( ::netput::rpc::MouseButton value);

  inline  ::netput::rpc::InputState getState();
  inline void setState( ::netput::rpc::InputState value);

  inline bool getDouble();
  inline void setDouble(bool value);

  inline  ::int32_t getX();
  inline void setX( ::int32_t value);

  inline  ::int32_t getY();
  inline void setY( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MouseButtonEvent::Pipeline {
public:
  typedef MouseButtonEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MouseWheelEvent::Reader {
public:
  typedef MouseWheelEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint32_t getWindowId() const;

  inline  ::int32_t getX() const;

  inline  ::int32_t getY() const;

  inline float getPreciseX() const;

  inline float getPreciseY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MouseWheelEvent::Builder {
public:
  typedef MouseWheelEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint32_t getWindowId();
  inline void setWindowId( ::uint32_t value);

  inline  ::int32_t getX();
  inline void setX( ::int32_t value);

  inline  ::int32_t getY();
  inline void setY( ::int32_t value);

  inline float getPreciseX();
  inline void setPreciseX(float value);

  inline float getPreciseY();
  inline void setPreciseY(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MouseWheelEvent::Pipeline {
public:
  typedef MouseWheelEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class KeyboardEvent::Reader {
public:
  typedef KeyboardEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint32_t getWindowId() const;

  inline  ::netput::rpc::InputState getState() const;

  inline bool getRepeat() const;

  inline  ::uint32_t getKeyCode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class KeyboardEvent::Builder {
public:
  typedef KeyboardEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint32_t getWindowId();
  inline void setWindowId( ::uint32_t value);

  inline  ::netput::rpc::InputState getState();
  inline void setState( ::netput::rpc::InputState value);

  inline bool getRepeat();
  inline void setRepeat(bool value);

  inline  ::uint32_t getKeyCode();
  inline void setKeyCode( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class KeyboardEvent::Pipeline {
public:
  typedef KeyboardEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class WindowEvent::Reader {
public:
  typedef WindowEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint32_t getWindowId() const;

  inline  ::netput::rpc::WindowEventType getType() const;

  inline  ::int32_t getArg1() const;

  inline  ::int32_t getArg2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class WindowEvent::Builder {
public:
  typedef WindowEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint32_t getWindowId();
  inline void setWindowId( ::uint32_t value);

  inline  ::netput::rpc::WindowEventType getType();
  inline void setType( ::netput::rpc::WindowEventType value);

  inline  ::int32_t getArg1();
  inline void setArg1( ::int32_t value);

  inline  ::int32_t getArg2();
  inline void setArg2( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class WindowEvent::Pipeline {
public:
  typedef WindowEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Netput::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Netput::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Netput::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Netput::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Netput::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::netput::rpc::Netput::Client& Netput::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::netput::rpc::Netput::Client& Netput::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Netput::ConnectParams::Reader::hasRequest() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netput::ConnectParams::Builder::hasRequest() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::ConnectRequest::Reader Netput::ConnectParams::Reader::getRequest() const {
  return ::capnp::_::PointerHelpers< ::netput::rpc::ConnectRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::ConnectRequest::Builder Netput::ConnectParams::Builder::getRequest() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::ConnectRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::netput::rpc::ConnectRequest::Pipeline Netput::ConnectParams::Pipeline::getRequest() {
  return  ::netput::rpc::ConnectRequest::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netput::ConnectParams::Builder::setRequest( ::netput::rpc::ConnectRequest::Reader value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::ConnectRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::ConnectRequest::Builder Netput::ConnectParams::Builder::initRequest() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::ConnectRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netput::ConnectParams::Builder::adoptRequest(
    ::capnp::Orphan< ::netput::rpc::ConnectRequest>&& value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::ConnectRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::ConnectRequest> Netput::ConnectParams::Builder::disownRequest() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::ConnectRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netput::ConnectResults::Reader::hasResponse() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netput::ConnectResults::Builder::hasResponse() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::ConnectResponse::Reader Netput::ConnectResults::Reader::getResponse() const {
  return ::capnp::_::PointerHelpers< ::netput::rpc::ConnectResponse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::ConnectResponse::Builder Netput::ConnectResults::Builder::getResponse() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::ConnectResponse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::netput::rpc::ConnectResponse::Pipeline Netput::ConnectResults::Pipeline::getResponse() {
  return  ::netput::rpc::ConnectResponse::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netput::ConnectResults::Builder::setResponse( ::netput::rpc::ConnectResponse::Reader value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::ConnectResponse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::ConnectResponse::Builder Netput::ConnectResults::Builder::initResponse() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::ConnectResponse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netput::ConnectResults::Builder::adoptResponse(
    ::capnp::Orphan< ::netput::rpc::ConnectResponse>&& value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::ConnectResponse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::ConnectResponse> Netput::ConnectResults::Builder::disownResponse() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::ConnectResponse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netput::PushParams::Reader::hasEvent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netput::PushParams::Builder::hasEvent() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::Event::Reader Netput::PushParams::Reader::getEvent() const {
  return ::capnp::_::PointerHelpers< ::netput::rpc::Event>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::Event::Builder Netput::PushParams::Builder::getEvent() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::Event>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::netput::rpc::Event::Pipeline Netput::PushParams::Pipeline::getEvent() {
  return  ::netput::rpc::Event::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netput::PushParams::Builder::setEvent( ::netput::rpc::Event::Reader value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::Event>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::Event::Builder Netput::PushParams::Builder::initEvent() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::Event>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netput::PushParams::Builder::adoptEvent(
    ::capnp::Orphan< ::netput::rpc::Event>&& value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::Event>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::Event> Netput::PushParams::Builder::disownEvent() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::Event>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netput::DisconnectParams::Reader::hasRequest() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netput::DisconnectParams::Builder::hasRequest() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::DisconnectRequest::Reader Netput::DisconnectParams::Reader::getRequest() const {
  return ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::DisconnectRequest::Builder Netput::DisconnectParams::Builder::getRequest() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::netput::rpc::DisconnectRequest::Pipeline Netput::DisconnectParams::Pipeline::getRequest() {
  return  ::netput::rpc::DisconnectRequest::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netput::DisconnectParams::Builder::setRequest( ::netput::rpc::DisconnectRequest::Reader value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::DisconnectRequest::Builder Netput::DisconnectParams::Builder::initRequest() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netput::DisconnectParams::Builder::adoptRequest(
    ::capnp::Orphan< ::netput::rpc::DisconnectRequest>&& value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::DisconnectRequest> Netput::DisconnectParams::Builder::disownRequest() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netput::DisconnectResults::Reader::hasResponse() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netput::DisconnectResults::Builder::hasResponse() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::DisconnectResponse::Reader Netput::DisconnectResults::Reader::getResponse() const {
  return ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectResponse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::DisconnectResponse::Builder Netput::DisconnectResults::Builder::getResponse() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectResponse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::netput::rpc::DisconnectResponse::Pipeline Netput::DisconnectResults::Pipeline::getResponse() {
  return  ::netput::rpc::DisconnectResponse::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netput::DisconnectResults::Builder::setResponse( ::netput::rpc::DisconnectResponse::Reader value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectResponse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::DisconnectResponse::Builder Netput::DisconnectResults::Builder::initResponse() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectResponse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netput::DisconnectResults::Builder::adoptResponse(
    ::capnp::Orphan< ::netput::rpc::DisconnectResponse>&& value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectResponse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::DisconnectResponse> Netput::DisconnectResults::Builder::disownResponse() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::DisconnectResponse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ConnectRequest::Reader::hasUserData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ConnectRequest::Builder::hasUserData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader ConnectRequest::Reader::getUserData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder ConnectRequest::Builder::getUserData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ConnectRequest::Builder::setUserData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder ConnectRequest::Builder::initUserData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ConnectRequest::Builder::adoptUserData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> ConnectRequest::Builder::disownUserData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename ConnectResponse::Message::Reader ConnectResponse::Reader::getMessage() const {
  return typename ConnectResponse::Message::Reader(_reader);
}
inline typename ConnectResponse::Message::Builder ConnectResponse::Builder::getMessage() {
  return typename ConnectResponse::Message::Builder(_builder);
}
#if !CAPNP_LITE
inline typename ConnectResponse::Message::Pipeline ConnectResponse::Pipeline::getMessage() {
  return typename ConnectResponse::Message::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename ConnectResponse::Message::Builder ConnectResponse::Builder::initMessage() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename ConnectResponse::Message::Builder(_builder);
}
inline  ::netput::rpc::ConnectResponse::Message::Which ConnectResponse::Message::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::netput::rpc::ConnectResponse::Message::Which ConnectResponse::Message::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool ConnectResponse::Message::Reader::isSessionId() const {
  return which() == ConnectResponse::Message::SESSION_ID;
}
inline bool ConnectResponse::Message::Builder::isSessionId() {
  return which() == ConnectResponse::Message::SESSION_ID;
}
inline bool ConnectResponse::Message::Reader::hasSessionId() const {
  if (which() != ConnectResponse::Message::SESSION_ID) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ConnectResponse::Message::Builder::hasSessionId() {
  if (which() != ConnectResponse::Message::SESSION_ID) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ConnectResponse::Message::Reader::getSessionId() const {
  KJ_IREQUIRE((which() == ConnectResponse::Message::SESSION_ID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ConnectResponse::Message::Builder::getSessionId() {
  KJ_IREQUIRE((which() == ConnectResponse::Message::SESSION_ID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ConnectResponse::Message::Builder::setSessionId( ::capnp::Text::Reader value) {
  _builder.setDataField<ConnectResponse::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ConnectResponse::Message::SESSION_ID);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ConnectResponse::Message::Builder::initSessionId(unsigned int size) {
  _builder.setDataField<ConnectResponse::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ConnectResponse::Message::SESSION_ID);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ConnectResponse::Message::Builder::adoptSessionId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<ConnectResponse::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ConnectResponse::Message::SESSION_ID);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ConnectResponse::Message::Builder::disownSessionId() {
  KJ_IREQUIRE((which() == ConnectResponse::Message::SESSION_ID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ConnectResponse::Message::Reader::isError() const {
  return which() == ConnectResponse::Message::ERROR;
}
inline bool ConnectResponse::Message::Builder::isError() {
  return which() == ConnectResponse::Message::ERROR;
}
inline bool ConnectResponse::Message::Reader::hasError() const {
  if (which() != ConnectResponse::Message::ERROR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ConnectResponse::Message::Builder::hasError() {
  if (which() != ConnectResponse::Message::ERROR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ConnectResponse::Message::Reader::getError() const {
  KJ_IREQUIRE((which() == ConnectResponse::Message::ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ConnectResponse::Message::Builder::getError() {
  KJ_IREQUIRE((which() == ConnectResponse::Message::ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ConnectResponse::Message::Builder::setError( ::capnp::Text::Reader value) {
  _builder.setDataField<ConnectResponse::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ConnectResponse::Message::ERROR);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ConnectResponse::Message::Builder::initError(unsigned int size) {
  _builder.setDataField<ConnectResponse::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ConnectResponse::Message::ERROR);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ConnectResponse::Message::Builder::adoptError(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<ConnectResponse::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ConnectResponse::Message::ERROR);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ConnectResponse::Message::Builder::disownError() {
  KJ_IREQUIRE((which() == ConnectResponse::Message::ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool DisconnectRequest::Reader::hasSessionId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DisconnectRequest::Builder::hasSessionId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader DisconnectRequest::Reader::getSessionId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder DisconnectRequest::Builder::getSessionId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DisconnectRequest::Builder::setSessionId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder DisconnectRequest::Builder::initSessionId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void DisconnectRequest::Builder::adoptSessionId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> DisconnectRequest::Builder::disownSessionId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool DisconnectResponse::Reader::hasError() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DisconnectResponse::Builder::hasError() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader DisconnectResponse::Reader::getError() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder DisconnectResponse::Builder::getError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DisconnectResponse::Builder::setError( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder DisconnectResponse::Builder::initError(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void DisconnectResponse::Builder::adoptError(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> DisconnectResponse::Builder::disownError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Event::Reader::hasSessionId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Builder::hasSessionId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Event::Reader::getSessionId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Event::Builder::getSessionId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Event::Builder::setSessionId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Event::Builder::initSessionId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Event::Builder::adoptSessionId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Event::Builder::disownSessionId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename Event::Info::Reader Event::Reader::getInfo() const {
  return typename Event::Info::Reader(_reader);
}
inline typename Event::Info::Builder Event::Builder::getInfo() {
  return typename Event::Info::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Event::Info::Pipeline Event::Pipeline::getInfo() {
  return typename Event::Info::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Event::Info::Builder Event::Builder::initInfo() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename Event::Info::Builder(_builder);
}
inline  ::netput::rpc::Event::Info::Which Event::Info::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::netput::rpc::Event::Info::Which Event::Info::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Event::Info::Reader::isMouseMotion() const {
  return which() == Event::Info::MOUSE_MOTION;
}
inline bool Event::Info::Builder::isMouseMotion() {
  return which() == Event::Info::MOUSE_MOTION;
}
inline bool Event::Info::Reader::hasMouseMotion() const {
  if (which() != Event::Info::MOUSE_MOTION) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Info::Builder::hasMouseMotion() {
  if (which() != Event::Info::MOUSE_MOTION) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::MouseMotionEvent::Reader Event::Info::Reader::getMouseMotion() const {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_MOTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::MouseMotionEvent::Builder Event::Info::Builder::getMouseMotion() {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_MOTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::setMouseMotion( ::netput::rpc::MouseMotionEvent::Reader value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_MOTION);
  ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::MouseMotionEvent::Builder Event::Info::Builder::initMouseMotion() {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_MOTION);
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::adoptMouseMotion(
    ::capnp::Orphan< ::netput::rpc::MouseMotionEvent>&& value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_MOTION);
  ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::MouseMotionEvent> Event::Info::Builder::disownMouseMotion() {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_MOTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Event::Info::Reader::isMouseButton() const {
  return which() == Event::Info::MOUSE_BUTTON;
}
inline bool Event::Info::Builder::isMouseButton() {
  return which() == Event::Info::MOUSE_BUTTON;
}
inline bool Event::Info::Reader::hasMouseButton() const {
  if (which() != Event::Info::MOUSE_BUTTON) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Info::Builder::hasMouseButton() {
  if (which() != Event::Info::MOUSE_BUTTON) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::MouseButtonEvent::Reader Event::Info::Reader::getMouseButton() const {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_BUTTON),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseButtonEvent>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::MouseButtonEvent::Builder Event::Info::Builder::getMouseButton() {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_BUTTON),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseButtonEvent>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::setMouseButton( ::netput::rpc::MouseButtonEvent::Reader value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_BUTTON);
  ::capnp::_::PointerHelpers< ::netput::rpc::MouseButtonEvent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::MouseButtonEvent::Builder Event::Info::Builder::initMouseButton() {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_BUTTON);
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseButtonEvent>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::adoptMouseButton(
    ::capnp::Orphan< ::netput::rpc::MouseButtonEvent>&& value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_BUTTON);
  ::capnp::_::PointerHelpers< ::netput::rpc::MouseButtonEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::MouseButtonEvent> Event::Info::Builder::disownMouseButton() {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_BUTTON),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseButtonEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Event::Info::Reader::isMouseWheel() const {
  return which() == Event::Info::MOUSE_WHEEL;
}
inline bool Event::Info::Builder::isMouseWheel() {
  return which() == Event::Info::MOUSE_WHEEL;
}
inline bool Event::Info::Reader::hasMouseWheel() const {
  if (which() != Event::Info::MOUSE_WHEEL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Info::Builder::hasMouseWheel() {
  if (which() != Event::Info::MOUSE_WHEEL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::MouseWheelEvent::Reader Event::Info::Reader::getMouseWheel() const {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_WHEEL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseWheelEvent>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::MouseWheelEvent::Builder Event::Info::Builder::getMouseWheel() {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_WHEEL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseWheelEvent>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::setMouseWheel( ::netput::rpc::MouseWheelEvent::Reader value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_WHEEL);
  ::capnp::_::PointerHelpers< ::netput::rpc::MouseWheelEvent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::MouseWheelEvent::Builder Event::Info::Builder::initMouseWheel() {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_WHEEL);
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseWheelEvent>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::adoptMouseWheel(
    ::capnp::Orphan< ::netput::rpc::MouseWheelEvent>&& value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::MOUSE_WHEEL);
  ::capnp::_::PointerHelpers< ::netput::rpc::MouseWheelEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::MouseWheelEvent> Event::Info::Builder::disownMouseWheel() {
  KJ_IREQUIRE((which() == Event::Info::MOUSE_WHEEL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseWheelEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Event::Info::Reader::isKeyboard() const {
  return which() == Event::Info::KEYBOARD;
}
inline bool Event::Info::Builder::isKeyboard() {
  return which() == Event::Info::KEYBOARD;
}
inline bool Event::Info::Reader::hasKeyboard() const {
  if (which() != Event::Info::KEYBOARD) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Info::Builder::hasKeyboard() {
  if (which() != Event::Info::KEYBOARD) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::KeyboardEvent::Reader Event::Info::Reader::getKeyboard() const {
  KJ_IREQUIRE((which() == Event::Info::KEYBOARD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::KeyboardEvent>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::KeyboardEvent::Builder Event::Info::Builder::getKeyboard() {
  KJ_IREQUIRE((which() == Event::Info::KEYBOARD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::KeyboardEvent>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::setKeyboard( ::netput::rpc::KeyboardEvent::Reader value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::KEYBOARD);
  ::capnp::_::PointerHelpers< ::netput::rpc::KeyboardEvent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::KeyboardEvent::Builder Event::Info::Builder::initKeyboard() {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::KEYBOARD);
  return ::capnp::_::PointerHelpers< ::netput::rpc::KeyboardEvent>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::adoptKeyboard(
    ::capnp::Orphan< ::netput::rpc::KeyboardEvent>&& value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::KEYBOARD);
  ::capnp::_::PointerHelpers< ::netput::rpc::KeyboardEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::KeyboardEvent> Event::Info::Builder::disownKeyboard() {
  KJ_IREQUIRE((which() == Event::Info::KEYBOARD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::KeyboardEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Event::Info::Reader::isWindow() const {
  return which() == Event::Info::WINDOW;
}
inline bool Event::Info::Builder::isWindow() {
  return which() == Event::Info::WINDOW;
}
inline bool Event::Info::Reader::hasWindow() const {
  if (which() != Event::Info::WINDOW) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Info::Builder::hasWindow() {
  if (which() != Event::Info::WINDOW) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::WindowEvent::Reader Event::Info::Reader::getWindow() const {
  KJ_IREQUIRE((which() == Event::Info::WINDOW),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::WindowEvent>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::WindowEvent::Builder Event::Info::Builder::getWindow() {
  KJ_IREQUIRE((which() == Event::Info::WINDOW),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::WindowEvent>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::setWindow( ::netput::rpc::WindowEvent::Reader value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::WINDOW);
  ::capnp::_::PointerHelpers< ::netput::rpc::WindowEvent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::WindowEvent::Builder Event::Info::Builder::initWindow() {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::WINDOW);
  return ::capnp::_::PointerHelpers< ::netput::rpc::WindowEvent>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Info::Builder::adoptWindow(
    ::capnp::Orphan< ::netput::rpc::WindowEvent>&& value) {
  _builder.setDataField<Event::Info::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Event::Info::WINDOW);
  ::capnp::_::PointerHelpers< ::netput::rpc::WindowEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::WindowEvent> Event::Info::Builder::disownWindow() {
  KJ_IREQUIRE((which() == Event::Info::WINDOW),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::netput::rpc::WindowEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint64_t MouseMotionEvent::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t MouseMotionEvent::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t MouseMotionEvent::Reader::getWindowId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t MouseMotionEvent::Builder::getWindowId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::Builder::setWindowId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool MouseMotionEvent::Reader::hasStateMask() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MouseMotionEvent::Builder::hasStateMask() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::netput::rpc::MouseMotionEvent::MouseStateMask::Reader MouseMotionEvent::Reader::getStateMask() const {
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent::MouseStateMask>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::netput::rpc::MouseMotionEvent::MouseStateMask::Builder MouseMotionEvent::Builder::getStateMask() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent::MouseStateMask>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::netput::rpc::MouseMotionEvent::MouseStateMask::Pipeline MouseMotionEvent::Pipeline::getStateMask() {
  return  ::netput::rpc::MouseMotionEvent::MouseStateMask::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MouseMotionEvent::Builder::setStateMask( ::netput::rpc::MouseMotionEvent::MouseStateMask::Reader value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent::MouseStateMask>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::netput::rpc::MouseMotionEvent::MouseStateMask::Builder MouseMotionEvent::Builder::initStateMask() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent::MouseStateMask>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MouseMotionEvent::Builder::adoptStateMask(
    ::capnp::Orphan< ::netput::rpc::MouseMotionEvent::MouseStateMask>&& value) {
  ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent::MouseStateMask>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::netput::rpc::MouseMotionEvent::MouseStateMask> MouseMotionEvent::Builder::disownStateMask() {
  return ::capnp::_::PointerHelpers< ::netput::rpc::MouseMotionEvent::MouseStateMask>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t MouseMotionEvent::Reader::getX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MouseMotionEvent::Builder::getX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::Builder::setX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MouseMotionEvent::Reader::getY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MouseMotionEvent::Builder::getY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::Builder::setY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MouseMotionEvent::Reader::getRelativeX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MouseMotionEvent::Builder::getRelativeX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::Builder::setRelativeX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MouseMotionEvent::Reader::getRelativeY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MouseMotionEvent::Builder::getRelativeY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::Builder::setRelativeY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Reader::getLeft() const {
  return _reader.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Builder::getLeft() {
  return _builder.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::MouseStateMask::Builder::setLeft( ::netput::rpc::InputState value) {
  _builder.setDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Reader::getMiddle() const {
  return _reader.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Builder::getMiddle() {
  return _builder.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::MouseStateMask::Builder::setMiddle( ::netput::rpc::InputState value) {
  _builder.setDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Reader::getRight() const {
  return _reader.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Builder::getRight() {
  return _builder.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::MouseStateMask::Builder::setRight( ::netput::rpc::InputState value) {
  _builder.setDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Reader::getX1() const {
  return _reader.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Builder::getX1() {
  return _builder.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::MouseStateMask::Builder::setX1( ::netput::rpc::InputState value) {
  _builder.setDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Reader::getX2() const {
  return _reader.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::InputState MouseMotionEvent::MouseStateMask::Builder::getX2() {
  return _builder.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void MouseMotionEvent::MouseStateMask::Builder::setX2( ::netput::rpc::InputState value) {
  _builder.setDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t MouseButtonEvent::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t MouseButtonEvent::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MouseButtonEvent::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t MouseButtonEvent::Reader::getWindowId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t MouseButtonEvent::Builder::getWindowId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MouseButtonEvent::Builder::setWindowId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::MouseButton MouseButtonEvent::Reader::getButton() const {
  return _reader.getDataField< ::netput::rpc::MouseButton>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::MouseButton MouseButtonEvent::Builder::getButton() {
  return _builder.getDataField< ::netput::rpc::MouseButton>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void MouseButtonEvent::Builder::setButton( ::netput::rpc::MouseButton value) {
  _builder.setDataField< ::netput::rpc::MouseButton>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::InputState MouseButtonEvent::Reader::getState() const {
  return _reader.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::InputState MouseButtonEvent::Builder::getState() {
  return _builder.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void MouseButtonEvent::Builder::setState( ::netput::rpc::InputState value) {
  _builder.setDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline bool MouseButtonEvent::Reader::getDouble() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}

inline bool MouseButtonEvent::Builder::getDouble() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}
inline void MouseButtonEvent::Builder::setDouble(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MouseButtonEvent::Reader::getX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MouseButtonEvent::Builder::getX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void MouseButtonEvent::Builder::setX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MouseButtonEvent::Reader::getY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MouseButtonEvent::Builder::getY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void MouseButtonEvent::Builder::setY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t MouseWheelEvent::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t MouseWheelEvent::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MouseWheelEvent::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t MouseWheelEvent::Reader::getWindowId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t MouseWheelEvent::Builder::getWindowId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MouseWheelEvent::Builder::setWindowId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MouseWheelEvent::Reader::getX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MouseWheelEvent::Builder::getX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void MouseWheelEvent::Builder::setX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t MouseWheelEvent::Reader::getY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MouseWheelEvent::Builder::getY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void MouseWheelEvent::Builder::setY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float MouseWheelEvent::Reader::getPreciseX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float MouseWheelEvent::Builder::getPreciseX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void MouseWheelEvent::Builder::setPreciseX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float MouseWheelEvent::Reader::getPreciseY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float MouseWheelEvent::Builder::getPreciseY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void MouseWheelEvent::Builder::setPreciseY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t KeyboardEvent::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t KeyboardEvent::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void KeyboardEvent::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t KeyboardEvent::Reader::getWindowId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t KeyboardEvent::Builder::getWindowId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void KeyboardEvent::Builder::setWindowId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::InputState KeyboardEvent::Reader::getState() const {
  return _reader.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::InputState KeyboardEvent::Builder::getState() {
  return _builder.getDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void KeyboardEvent::Builder::setState( ::netput::rpc::InputState value) {
  _builder.setDataField< ::netput::rpc::InputState>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool KeyboardEvent::Reader::getRepeat() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<112>() * ::capnp::ELEMENTS);
}

inline bool KeyboardEvent::Builder::getRepeat() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<112>() * ::capnp::ELEMENTS);
}
inline void KeyboardEvent::Builder::setRepeat(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<112>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t KeyboardEvent::Reader::getKeyCode() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t KeyboardEvent::Builder::getKeyCode() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void KeyboardEvent::Builder::setKeyCode( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t WindowEvent::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t WindowEvent::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void WindowEvent::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t WindowEvent::Reader::getWindowId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t WindowEvent::Builder::getWindowId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void WindowEvent::Builder::setWindowId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::netput::rpc::WindowEventType WindowEvent::Reader::getType() const {
  return _reader.getDataField< ::netput::rpc::WindowEventType>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::netput::rpc::WindowEventType WindowEvent::Builder::getType() {
  return _builder.getDataField< ::netput::rpc::WindowEventType>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void WindowEvent::Builder::setType( ::netput::rpc::WindowEventType value) {
  _builder.setDataField< ::netput::rpc::WindowEventType>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t WindowEvent::Reader::getArg1() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t WindowEvent::Builder::getArg1() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void WindowEvent::Builder::setArg1( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t WindowEvent::Reader::getArg2() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t WindowEvent::Builder::getArg2() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void WindowEvent::Builder::setArg2( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

