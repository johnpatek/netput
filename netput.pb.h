// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: netput.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_netput_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_netput_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_netput_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_netput_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_netput_2eproto;
namespace netput {
namespace internal {
class ConnectRequest;
struct ConnectRequestDefaultTypeInternal;
extern ConnectRequestDefaultTypeInternal _ConnectRequest_default_instance_;
class ConnectResponse;
struct ConnectResponseDefaultTypeInternal;
extern ConnectResponseDefaultTypeInternal _ConnectResponse_default_instance_;
class DisconnectRequest;
struct DisconnectRequestDefaultTypeInternal;
extern DisconnectRequestDefaultTypeInternal _DisconnectRequest_default_instance_;
class DisconnectResponse;
struct DisconnectResponseDefaultTypeInternal;
extern DisconnectResponseDefaultTypeInternal _DisconnectResponse_default_instance_;
class EventRequest;
struct EventRequestDefaultTypeInternal;
extern EventRequestDefaultTypeInternal _EventRequest_default_instance_;
class EventResponse;
struct EventResponseDefaultTypeInternal;
extern EventResponseDefaultTypeInternal _EventResponse_default_instance_;
class KeyboardEvent;
struct KeyboardEventDefaultTypeInternal;
extern KeyboardEventDefaultTypeInternal _KeyboardEvent_default_instance_;
class MouseButtonEvent;
struct MouseButtonEventDefaultTypeInternal;
extern MouseButtonEventDefaultTypeInternal _MouseButtonEvent_default_instance_;
class MouseButtonStateMask;
struct MouseButtonStateMaskDefaultTypeInternal;
extern MouseButtonStateMaskDefaultTypeInternal _MouseButtonStateMask_default_instance_;
class MouseMotionEvent;
struct MouseMotionEventDefaultTypeInternal;
extern MouseMotionEventDefaultTypeInternal _MouseMotionEvent_default_instance_;
class MouseWheelEvent;
struct MouseWheelEventDefaultTypeInternal;
extern MouseWheelEventDefaultTypeInternal _MouseWheelEvent_default_instance_;
class WindowEvent;
struct WindowEventDefaultTypeInternal;
extern WindowEventDefaultTypeInternal _WindowEvent_default_instance_;
}  // namespace internal
}  // namespace netput
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace netput {
namespace internal {
enum EventType : int {
  MouseMotionType = 0,
  MouseButtonType = 1,
  MouseWheelType = 2,
  KeyboardType = 3,
  WindowType = 4,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EventType_IsValid(int value);
extern const uint32_t EventType_internal_data_[];
constexpr EventType EventType_MIN = static_cast<EventType>(0);
constexpr EventType EventType_MAX = static_cast<EventType>(4);
constexpr int EventType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
EventType_descriptor();
template <typename T>
const std::string& EventType_Name(T value) {
  static_assert(std::is_same<T, EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return EventType_Name(static_cast<EventType>(value));
}
template <>
inline const std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EventType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool EventType_Parse(absl::string_view name, EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(
      EventType_descriptor(), name, value);
}
enum KeyState : int {
  Up = 0,
  Down = 1,
  KeyState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  KeyState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool KeyState_IsValid(int value);
extern const uint32_t KeyState_internal_data_[];
constexpr KeyState KeyState_MIN = static_cast<KeyState>(0);
constexpr KeyState KeyState_MAX = static_cast<KeyState>(1);
constexpr int KeyState_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
KeyState_descriptor();
template <typename T>
const std::string& KeyState_Name(T value) {
  static_assert(std::is_same<T, KeyState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to KeyState_Name().");
  return KeyState_Name(static_cast<KeyState>(value));
}
template <>
inline const std::string& KeyState_Name(KeyState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<KeyState_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool KeyState_Parse(absl::string_view name, KeyState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyState>(
      KeyState_descriptor(), name, value);
}
enum MouseButton : int {
  Left = 0,
  Middle = 1,
  Right = 2,
  X1 = 3,
  X2 = 4,
  MouseButton_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MouseButton_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MouseButton_IsValid(int value);
extern const uint32_t MouseButton_internal_data_[];
constexpr MouseButton MouseButton_MIN = static_cast<MouseButton>(0);
constexpr MouseButton MouseButton_MAX = static_cast<MouseButton>(4);
constexpr int MouseButton_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
MouseButton_descriptor();
template <typename T>
const std::string& MouseButton_Name(T value) {
  static_assert(std::is_same<T, MouseButton>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MouseButton_Name().");
  return MouseButton_Name(static_cast<MouseButton>(value));
}
template <>
inline const std::string& MouseButton_Name(MouseButton value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MouseButton_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool MouseButton_Parse(absl::string_view name, MouseButton* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MouseButton>(
      MouseButton_descriptor(), name, value);
}
enum MouseState : int {
  Press = 0,
  Release = 1,
  MouseState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MouseState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MouseState_IsValid(int value);
extern const uint32_t MouseState_internal_data_[];
constexpr MouseState MouseState_MIN = static_cast<MouseState>(0);
constexpr MouseState MouseState_MAX = static_cast<MouseState>(1);
constexpr int MouseState_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
MouseState_descriptor();
template <typename T>
const std::string& MouseState_Name(T value) {
  static_assert(std::is_same<T, MouseState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MouseState_Name().");
  return MouseState_Name(static_cast<MouseState>(value));
}
template <>
inline const std::string& MouseState_Name(MouseState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MouseState_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool MouseState_Parse(absl::string_view name, MouseState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MouseState>(
      MouseState_descriptor(), name, value);
}
enum WindowEventType : int {
  ShownType = 0,
  HiddenType = 1,
  ExposedType = 2,
  MovedType = 3,
  ResizedType = 4,
  MinimizedType = 5,
  MaximizedType = 6,
  RestoredType = 7,
  MouseEnterType = 8,
  MouseLeaveType = 9,
  FocusGainedType = 10,
  FocusLostType = 11,
  WindowEventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WindowEventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WindowEventType_IsValid(int value);
extern const uint32_t WindowEventType_internal_data_[];
constexpr WindowEventType WindowEventType_MIN = static_cast<WindowEventType>(0);
constexpr WindowEventType WindowEventType_MAX = static_cast<WindowEventType>(11);
constexpr int WindowEventType_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
WindowEventType_descriptor();
template <typename T>
const std::string& WindowEventType_Name(T value) {
  static_assert(std::is_same<T, WindowEventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WindowEventType_Name().");
  return WindowEventType_Name(static_cast<WindowEventType>(value));
}
template <>
inline const std::string& WindowEventType_Name(WindowEventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WindowEventType_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool WindowEventType_Parse(absl::string_view name, WindowEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WindowEventType>(
      WindowEventType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WindowEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.WindowEvent) */ {
 public:
  inline WindowEvent() : WindowEvent(nullptr) {}
  ~WindowEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WindowEvent(::google::protobuf::internal::ConstantInitialized);

  inline WindowEvent(const WindowEvent& from)
      : WindowEvent(nullptr, from) {}
  WindowEvent(WindowEvent&& from) noexcept
    : WindowEvent() {
    *this = ::std::move(from);
  }

  inline WindowEvent& operator=(const WindowEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowEvent& operator=(WindowEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowEvent* internal_default_instance() {
    return reinterpret_cast<const WindowEvent*>(
               &_WindowEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WindowEvent& a, WindowEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WindowEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WindowEvent& from) {
    WindowEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WindowEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.WindowEvent";
  }
  protected:
  explicit WindowEvent(::google::protobuf::Arena* arena);
  WindowEvent(::google::protobuf::Arena* arena, const WindowEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kWindowIDFieldNumber = 2,
    kTypeFieldNumber = 3,
    kArg1FieldNumber = 4,
    kArg2FieldNumber = 5,
  };
  // uint64 Timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 WindowID = 2;
  void clear_windowid() ;
  ::uint32_t windowid() const;
  void set_windowid(::uint32_t value);

  private:
  ::uint32_t _internal_windowid() const;
  void _internal_set_windowid(::uint32_t value);

  public:
  // .netput.internal.WindowEventType Type = 3;
  void clear_type() ;
  ::netput::internal::WindowEventType type() const;
  void set_type(::netput::internal::WindowEventType value);

  private:
  ::netput::internal::WindowEventType _internal_type() const;
  void _internal_set_type(::netput::internal::WindowEventType value);

  public:
  // sint32 Arg1 = 4;
  void clear_arg1() ;
  ::int32_t arg1() const;
  void set_arg1(::int32_t value);

  private:
  ::int32_t _internal_arg1() const;
  void _internal_set_arg1(::int32_t value);

  public:
  // sint32 Arg2 = 5;
  void clear_arg2() ;
  ::int32_t arg2() const;
  void set_arg2(::int32_t value);

  private:
  ::int32_t _internal_arg2() const;
  void _internal_set_arg2(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.WindowEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t timestamp_;
    ::uint32_t windowid_;
    int type_;
    ::int32_t arg1_;
    ::int32_t arg2_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class MouseWheelEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.MouseWheelEvent) */ {
 public:
  inline MouseWheelEvent() : MouseWheelEvent(nullptr) {}
  ~MouseWheelEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MouseWheelEvent(::google::protobuf::internal::ConstantInitialized);

  inline MouseWheelEvent(const MouseWheelEvent& from)
      : MouseWheelEvent(nullptr, from) {}
  MouseWheelEvent(MouseWheelEvent&& from) noexcept
    : MouseWheelEvent() {
    *this = ::std::move(from);
  }

  inline MouseWheelEvent& operator=(const MouseWheelEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseWheelEvent& operator=(MouseWheelEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseWheelEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseWheelEvent* internal_default_instance() {
    return reinterpret_cast<const MouseWheelEvent*>(
               &_MouseWheelEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MouseWheelEvent& a, MouseWheelEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseWheelEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseWheelEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseWheelEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseWheelEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MouseWheelEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MouseWheelEvent& from) {
    MouseWheelEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MouseWheelEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.MouseWheelEvent";
  }
  protected:
  explicit MouseWheelEvent(::google::protobuf::Arena* arena);
  MouseWheelEvent(::google::protobuf::Arena* arena, const MouseWheelEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kWindowIDFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kPreciseXFieldNumber = 5,
    kPreciceYFieldNumber = 6,
  };
  // uint64 Timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 WindowID = 2;
  void clear_windowid() ;
  ::uint32_t windowid() const;
  void set_windowid(::uint32_t value);

  private:
  ::uint32_t _internal_windowid() const;
  void _internal_set_windowid(::uint32_t value);

  public:
  // sint32 X = 3;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // sint32 Y = 4;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // float PreciseX = 5;
  void clear_precisex() ;
  float precisex() const;
  void set_precisex(float value);

  private:
  float _internal_precisex() const;
  void _internal_set_precisex(float value);

  public:
  // float PreciceY = 6;
  void clear_precicey() ;
  float precicey() const;
  void set_precicey(float value);

  private:
  float _internal_precicey() const;
  void _internal_set_precicey(float value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.MouseWheelEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t timestamp_;
    ::uint32_t windowid_;
    ::int32_t x_;
    ::int32_t y_;
    float precisex_;
    float precicey_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class MouseButtonStateMask final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.MouseButtonStateMask) */ {
 public:
  inline MouseButtonStateMask() : MouseButtonStateMask(nullptr) {}
  ~MouseButtonStateMask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MouseButtonStateMask(::google::protobuf::internal::ConstantInitialized);

  inline MouseButtonStateMask(const MouseButtonStateMask& from)
      : MouseButtonStateMask(nullptr, from) {}
  MouseButtonStateMask(MouseButtonStateMask&& from) noexcept
    : MouseButtonStateMask() {
    *this = ::std::move(from);
  }

  inline MouseButtonStateMask& operator=(const MouseButtonStateMask& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseButtonStateMask& operator=(MouseButtonStateMask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseButtonStateMask& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseButtonStateMask* internal_default_instance() {
    return reinterpret_cast<const MouseButtonStateMask*>(
               &_MouseButtonStateMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MouseButtonStateMask& a, MouseButtonStateMask& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseButtonStateMask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseButtonStateMask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseButtonStateMask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseButtonStateMask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MouseButtonStateMask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MouseButtonStateMask& from) {
    MouseButtonStateMask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MouseButtonStateMask* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.MouseButtonStateMask";
  }
  protected:
  explicit MouseButtonStateMask(::google::protobuf::Arena* arena);
  MouseButtonStateMask(::google::protobuf::Arena* arena, const MouseButtonStateMask& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kMiddleFieldNumber = 2,
    kRightFieldNumber = 3,
    kX1FieldNumber = 4,
    kX2FieldNumber = 5,
  };
  // .netput.internal.MouseState Left = 1;
  void clear_left() ;
  ::netput::internal::MouseState left() const;
  void set_left(::netput::internal::MouseState value);

  private:
  ::netput::internal::MouseState _internal_left() const;
  void _internal_set_left(::netput::internal::MouseState value);

  public:
  // .netput.internal.MouseState Middle = 2;
  void clear_middle() ;
  ::netput::internal::MouseState middle() const;
  void set_middle(::netput::internal::MouseState value);

  private:
  ::netput::internal::MouseState _internal_middle() const;
  void _internal_set_middle(::netput::internal::MouseState value);

  public:
  // .netput.internal.MouseState Right = 3;
  void clear_right() ;
  ::netput::internal::MouseState right() const;
  void set_right(::netput::internal::MouseState value);

  private:
  ::netput::internal::MouseState _internal_right() const;
  void _internal_set_right(::netput::internal::MouseState value);

  public:
  // .netput.internal.MouseState X1 = 4;
  void clear_x1() ;
  ::netput::internal::MouseState x1() const;
  void set_x1(::netput::internal::MouseState value);

  private:
  ::netput::internal::MouseState _internal_x1() const;
  void _internal_set_x1(::netput::internal::MouseState value);

  public:
  // .netput.internal.MouseState X2 = 5;
  void clear_x2() ;
  ::netput::internal::MouseState x2() const;
  void set_x2(::netput::internal::MouseState value);

  private:
  ::netput::internal::MouseState _internal_x2() const;
  void _internal_set_x2(::netput::internal::MouseState value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.MouseButtonStateMask)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int left_;
    int middle_;
    int right_;
    int x1_;
    int x2_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class MouseButtonEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.MouseButtonEvent) */ {
 public:
  inline MouseButtonEvent() : MouseButtonEvent(nullptr) {}
  ~MouseButtonEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MouseButtonEvent(::google::protobuf::internal::ConstantInitialized);

  inline MouseButtonEvent(const MouseButtonEvent& from)
      : MouseButtonEvent(nullptr, from) {}
  MouseButtonEvent(MouseButtonEvent&& from) noexcept
    : MouseButtonEvent() {
    *this = ::std::move(from);
  }

  inline MouseButtonEvent& operator=(const MouseButtonEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseButtonEvent& operator=(MouseButtonEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseButtonEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseButtonEvent* internal_default_instance() {
    return reinterpret_cast<const MouseButtonEvent*>(
               &_MouseButtonEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MouseButtonEvent& a, MouseButtonEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseButtonEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseButtonEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseButtonEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseButtonEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MouseButtonEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MouseButtonEvent& from) {
    MouseButtonEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MouseButtonEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.MouseButtonEvent";
  }
  protected:
  explicit MouseButtonEvent(::google::protobuf::Arena* arena);
  MouseButtonEvent(::google::protobuf::Arena* arena, const MouseButtonEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kWindowIDFieldNumber = 2,
    kButtonFieldNumber = 3,
    kStateFieldNumber = 4,
    kDoubleClickFieldNumber = 5,
    kXFieldNumber = 6,
    kYFieldNumber = 7,
  };
  // uint64 Timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 WindowID = 2;
  void clear_windowid() ;
  ::uint32_t windowid() const;
  void set_windowid(::uint32_t value);

  private:
  ::uint32_t _internal_windowid() const;
  void _internal_set_windowid(::uint32_t value);

  public:
  // .netput.internal.MouseButton Button = 3;
  void clear_button() ;
  ::netput::internal::MouseButton button() const;
  void set_button(::netput::internal::MouseButton value);

  private:
  ::netput::internal::MouseButton _internal_button() const;
  void _internal_set_button(::netput::internal::MouseButton value);

  public:
  // .netput.internal.MouseState State = 4;
  void clear_state() ;
  ::netput::internal::MouseState state() const;
  void set_state(::netput::internal::MouseState value);

  private:
  ::netput::internal::MouseState _internal_state() const;
  void _internal_set_state(::netput::internal::MouseState value);

  public:
  // bool DoubleClick = 5;
  void clear_doubleclick() ;
  bool doubleclick() const;
  void set_doubleclick(bool value);

  private:
  bool _internal_doubleclick() const;
  void _internal_set_doubleclick(bool value);

  public:
  // sint32 X = 6;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // sint32 Y = 7;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.MouseButtonEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t timestamp_;
    ::uint32_t windowid_;
    int button_;
    int state_;
    bool doubleclick_;
    ::int32_t x_;
    ::int32_t y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class KeyboardEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.KeyboardEvent) */ {
 public:
  inline KeyboardEvent() : KeyboardEvent(nullptr) {}
  ~KeyboardEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KeyboardEvent(::google::protobuf::internal::ConstantInitialized);

  inline KeyboardEvent(const KeyboardEvent& from)
      : KeyboardEvent(nullptr, from) {}
  KeyboardEvent(KeyboardEvent&& from) noexcept
    : KeyboardEvent() {
    *this = ::std::move(from);
  }

  inline KeyboardEvent& operator=(const KeyboardEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyboardEvent& operator=(KeyboardEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyboardEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyboardEvent* internal_default_instance() {
    return reinterpret_cast<const KeyboardEvent*>(
               &_KeyboardEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(KeyboardEvent& a, KeyboardEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyboardEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyboardEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyboardEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyboardEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyboardEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const KeyboardEvent& from) {
    KeyboardEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyboardEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.KeyboardEvent";
  }
  protected:
  explicit KeyboardEvent(::google::protobuf::Arena* arena);
  KeyboardEvent(::google::protobuf::Arena* arena, const KeyboardEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kWindowIDFieldNumber = 2,
    kStateFieldNumber = 3,
    kRepeatFieldNumber = 4,
    kKeyCodeFieldNumber = 5,
  };
  // uint64 Timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 WindowID = 2;
  void clear_windowid() ;
  ::uint32_t windowid() const;
  void set_windowid(::uint32_t value);

  private:
  ::uint32_t _internal_windowid() const;
  void _internal_set_windowid(::uint32_t value);

  public:
  // .netput.internal.KeyState State = 3;
  void clear_state() ;
  ::netput::internal::KeyState state() const;
  void set_state(::netput::internal::KeyState value);

  private:
  ::netput::internal::KeyState _internal_state() const;
  void _internal_set_state(::netput::internal::KeyState value);

  public:
  // bool Repeat = 4;
  void clear_repeat() ;
  bool repeat() const;
  void set_repeat(bool value);

  private:
  bool _internal_repeat() const;
  void _internal_set_repeat(bool value);

  public:
  // uint32 KeyCode = 5;
  void clear_keycode() ;
  ::uint32_t keycode() const;
  void set_keycode(::uint32_t value);

  private:
  ::uint32_t _internal_keycode() const;
  void _internal_set_keycode(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.KeyboardEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t timestamp_;
    ::uint32_t windowid_;
    int state_;
    bool repeat_;
    ::uint32_t keycode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class EventResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.EventResponse) */ {
 public:
  inline EventResponse() : EventResponse(nullptr) {}
  ~EventResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventResponse(::google::protobuf::internal::ConstantInitialized);

  inline EventResponse(const EventResponse& from)
      : EventResponse(nullptr, from) {}
  EventResponse(EventResponse&& from) noexcept
    : EventResponse() {
    *this = ::std::move(from);
  }

  inline EventResponse& operator=(const EventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventResponse& operator=(EventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventResponse* internal_default_instance() {
    return reinterpret_cast<const EventResponse*>(
               &_EventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EventResponse& a, EventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EventResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EventResponse& from) {
    EventResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EventResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.EventResponse";
  }
  protected:
  explicit EventResponse(::google::protobuf::Arena* arena);
  EventResponse(::google::protobuf::Arena* arena, const EventResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string Error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // bool Success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.EventResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class DisconnectResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.DisconnectResponse) */ {
 public:
  inline DisconnectResponse() : DisconnectResponse(nullptr) {}
  ~DisconnectResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DisconnectResponse(::google::protobuf::internal::ConstantInitialized);

  inline DisconnectResponse(const DisconnectResponse& from)
      : DisconnectResponse(nullptr, from) {}
  DisconnectResponse(DisconnectResponse&& from) noexcept
    : DisconnectResponse() {
    *this = ::std::move(from);
  }

  inline DisconnectResponse& operator=(const DisconnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectResponse& operator=(DisconnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectResponse* internal_default_instance() {
    return reinterpret_cast<const DisconnectResponse*>(
               &_DisconnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DisconnectResponse& a, DisconnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DisconnectResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DisconnectResponse& from) {
    DisconnectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DisconnectResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.DisconnectResponse";
  }
  protected:
  explicit DisconnectResponse(::google::protobuf::Arena* arena);
  DisconnectResponse(::google::protobuf::Arena* arena, const DisconnectResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string Error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // bool Success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.DisconnectResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr error_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class DisconnectRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.DisconnectRequest) */ {
 public:
  inline DisconnectRequest() : DisconnectRequest(nullptr) {}
  ~DisconnectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DisconnectRequest(::google::protobuf::internal::ConstantInitialized);

  inline DisconnectRequest(const DisconnectRequest& from)
      : DisconnectRequest(nullptr, from) {}
  DisconnectRequest(DisconnectRequest&& from) noexcept
    : DisconnectRequest() {
    *this = ::std::move(from);
  }

  inline DisconnectRequest& operator=(const DisconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectRequest& operator=(DisconnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectRequest* internal_default_instance() {
    return reinterpret_cast<const DisconnectRequest*>(
               &_DisconnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DisconnectRequest& a, DisconnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DisconnectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DisconnectRequest& from) {
    DisconnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DisconnectRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.DisconnectRequest";
  }
  protected:
  explicit DisconnectRequest(::google::protobuf::Arena* arena);
  DisconnectRequest(::google::protobuf::Arena* arena, const DisconnectRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIDFieldNumber = 1,
  };
  // string SessionID = 1;
  void clear_sessionid() ;
  const std::string& sessionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sessionid(Arg_&& arg, Args_... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* value);

  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(
      const std::string& value);
  std::string* _internal_mutable_sessionid();

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.DisconnectRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr sessionid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class ConnectResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.ConnectResponse) */ {
 public:
  inline ConnectResponse() : ConnectResponse(nullptr) {}
  ~ConnectResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectResponse(::google::protobuf::internal::ConstantInitialized);

  inline ConnectResponse(const ConnectResponse& from)
      : ConnectResponse(nullptr, from) {}
  ConnectResponse(ConnectResponse&& from) noexcept
    : ConnectResponse() {
    *this = ::std::move(from);
  }

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectResponse& operator=(ConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectResponse*>(
               &_ConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConnectResponse& a, ConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConnectResponse& from) {
    ConnectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConnectResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.ConnectResponse";
  }
  protected:
  explicit ConnectResponse(::google::protobuf::Arena* arena);
  ConnectResponse(::google::protobuf::Arena* arena, const ConnectResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIDFieldNumber = 2,
    kErrorFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string SessionID = 2;
  void clear_sessionid() ;
  const std::string& sessionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sessionid(Arg_&& arg, Args_... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* value);

  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(
      const std::string& value);
  std::string* _internal_mutable_sessionid();

  public:
  // string Error = 3;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* value);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.ConnectResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr sessionid_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class ConnectRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.ConnectRequest) */ {
 public:
  inline ConnectRequest() : ConnectRequest(nullptr) {}
  ~ConnectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectRequest(::google::protobuf::internal::ConstantInitialized);

  inline ConnectRequest(const ConnectRequest& from)
      : ConnectRequest(nullptr, from) {}
  ConnectRequest(ConnectRequest&& from) noexcept
    : ConnectRequest() {
    *this = ::std::move(from);
  }

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectRequest& operator=(ConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectRequest*>(
               &_ConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConnectRequest& a, ConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConnectRequest& from) {
    ConnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConnectRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.ConnectRequest";
  }
  protected:
  explicit ConnectRequest(::google::protobuf::Arena* arena);
  ConnectRequest(::google::protobuf::Arena* arena, const ConnectRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 1,
  };
  // bytes UserData = 1;
  void clear_userdata() ;
  const std::string& userdata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userdata(Arg_&& arg, Args_... args);
  std::string* mutable_userdata();
  PROTOBUF_NODISCARD std::string* release_userdata();
  void set_allocated_userdata(std::string* value);

  private:
  const std::string& _internal_userdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userdata(
      const std::string& value);
  std::string* _internal_mutable_userdata();

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.ConnectRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr userdata_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class MouseMotionEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.MouseMotionEvent) */ {
 public:
  inline MouseMotionEvent() : MouseMotionEvent(nullptr) {}
  ~MouseMotionEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MouseMotionEvent(::google::protobuf::internal::ConstantInitialized);

  inline MouseMotionEvent(const MouseMotionEvent& from)
      : MouseMotionEvent(nullptr, from) {}
  MouseMotionEvent(MouseMotionEvent&& from) noexcept
    : MouseMotionEvent() {
    *this = ::std::move(from);
  }

  inline MouseMotionEvent& operator=(const MouseMotionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseMotionEvent& operator=(MouseMotionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseMotionEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseMotionEvent* internal_default_instance() {
    return reinterpret_cast<const MouseMotionEvent*>(
               &_MouseMotionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MouseMotionEvent& a, MouseMotionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseMotionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseMotionEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseMotionEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseMotionEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MouseMotionEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MouseMotionEvent& from) {
    MouseMotionEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MouseMotionEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.MouseMotionEvent";
  }
  protected:
  explicit MouseMotionEvent(::google::protobuf::Arena* arena);
  MouseMotionEvent(::google::protobuf::Arena* arena, const MouseMotionEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateMaskFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kWindowIDFieldNumber = 2,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
    kRelativeXFieldNumber = 6,
    kRelativeYFieldNumber = 7,
  };
  // .netput.internal.MouseButtonStateMask StateMask = 3;
  bool has_statemask() const;
  void clear_statemask() ;
  const ::netput::internal::MouseButtonStateMask& statemask() const;
  PROTOBUF_NODISCARD ::netput::internal::MouseButtonStateMask* release_statemask();
  ::netput::internal::MouseButtonStateMask* mutable_statemask();
  void set_allocated_statemask(::netput::internal::MouseButtonStateMask* value);
  void unsafe_arena_set_allocated_statemask(::netput::internal::MouseButtonStateMask* value);
  ::netput::internal::MouseButtonStateMask* unsafe_arena_release_statemask();

  private:
  const ::netput::internal::MouseButtonStateMask& _internal_statemask() const;
  ::netput::internal::MouseButtonStateMask* _internal_mutable_statemask();

  public:
  // uint64 Timestamp = 1;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 WindowID = 2;
  void clear_windowid() ;
  ::uint32_t windowid() const;
  void set_windowid(::uint32_t value);

  private:
  ::uint32_t _internal_windowid() const;
  void _internal_set_windowid(::uint32_t value);

  public:
  // sint32 X = 4;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // sint32 Y = 5;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // sint32 RelativeX = 6;
  void clear_relativex() ;
  ::int32_t relativex() const;
  void set_relativex(::int32_t value);

  private:
  ::int32_t _internal_relativex() const;
  void _internal_set_relativex(::int32_t value);

  public:
  // sint32 RelativeY = 7;
  void clear_relativey() ;
  ::int32_t relativey() const;
  void set_relativey(::int32_t value);

  private:
  ::int32_t _internal_relativey() const;
  void _internal_set_relativey(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:netput.internal.MouseMotionEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::netput::internal::MouseButtonStateMask* statemask_;
    ::uint64_t timestamp_;
    ::uint32_t windowid_;
    ::int32_t x_;
    ::int32_t y_;
    ::int32_t relativex_;
    ::int32_t relativey_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};// -------------------------------------------------------------------

class EventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netput.internal.EventRequest) */ {
 public:
  inline EventRequest() : EventRequest(nullptr) {}
  ~EventRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventRequest(::google::protobuf::internal::ConstantInitialized);

  inline EventRequest(const EventRequest& from)
      : EventRequest(nullptr, from) {}
  EventRequest(EventRequest&& from) noexcept
    : EventRequest() {
    *this = ::std::move(from);
  }

  inline EventRequest& operator=(const EventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventRequest& operator=(EventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventRequest& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kMouseMotion = 3,
    kMouseButton = 4,
    kMouseWheel = 5,
    kKeyboard = 6,
    kWindow = 7,
    EVENT_NOT_SET = 0,
  };

  static inline const EventRequest* internal_default_instance() {
    return reinterpret_cast<const EventRequest*>(
               &_EventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EventRequest& a, EventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EventRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EventRequest& from) {
    EventRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EventRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "netput.internal.EventRequest";
  }
  protected:
  explicit EventRequest(::google::protobuf::Arena* arena);
  EventRequest(::google::protobuf::Arena* arena, const EventRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIDFieldNumber = 1,
    kTypeFieldNumber = 2,
    kMouseMotionFieldNumber = 3,
    kMouseButtonFieldNumber = 4,
    kMouseWheelFieldNumber = 5,
    kKeyboardFieldNumber = 6,
    kWindowFieldNumber = 7,
  };
  // string SessionID = 1;
  void clear_sessionid() ;
  const std::string& sessionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sessionid(Arg_&& arg, Args_... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* value);

  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(
      const std::string& value);
  std::string* _internal_mutable_sessionid();

  public:
  // .netput.internal.EventType Type = 2;
  void clear_type() ;
  ::netput::internal::EventType type() const;
  void set_type(::netput::internal::EventType value);

  private:
  ::netput::internal::EventType _internal_type() const;
  void _internal_set_type(::netput::internal::EventType value);

  public:
  // .netput.internal.MouseMotionEvent MouseMotion = 3;
  bool has_mousemotion() const;
  private:
  bool _internal_has_mousemotion() const;

  public:
  void clear_mousemotion() ;
  const ::netput::internal::MouseMotionEvent& mousemotion() const;
  PROTOBUF_NODISCARD ::netput::internal::MouseMotionEvent* release_mousemotion();
  ::netput::internal::MouseMotionEvent* mutable_mousemotion();
  void set_allocated_mousemotion(::netput::internal::MouseMotionEvent* value);
  void unsafe_arena_set_allocated_mousemotion(::netput::internal::MouseMotionEvent* value);
  ::netput::internal::MouseMotionEvent* unsafe_arena_release_mousemotion();

  private:
  const ::netput::internal::MouseMotionEvent& _internal_mousemotion() const;
  ::netput::internal::MouseMotionEvent* _internal_mutable_mousemotion();

  public:
  // .netput.internal.MouseButtonEvent MouseButton = 4;
  bool has_mousebutton() const;
  private:
  bool _internal_has_mousebutton() const;

  public:
  void clear_mousebutton() ;
  const ::netput::internal::MouseButtonEvent& mousebutton() const;
  PROTOBUF_NODISCARD ::netput::internal::MouseButtonEvent* release_mousebutton();
  ::netput::internal::MouseButtonEvent* mutable_mousebutton();
  void set_allocated_mousebutton(::netput::internal::MouseButtonEvent* value);
  void unsafe_arena_set_allocated_mousebutton(::netput::internal::MouseButtonEvent* value);
  ::netput::internal::MouseButtonEvent* unsafe_arena_release_mousebutton();

  private:
  const ::netput::internal::MouseButtonEvent& _internal_mousebutton() const;
  ::netput::internal::MouseButtonEvent* _internal_mutable_mousebutton();

  public:
  // .netput.internal.MouseWheelEvent MouseWheel = 5;
  bool has_mousewheel() const;
  private:
  bool _internal_has_mousewheel() const;

  public:
  void clear_mousewheel() ;
  const ::netput::internal::MouseWheelEvent& mousewheel() const;
  PROTOBUF_NODISCARD ::netput::internal::MouseWheelEvent* release_mousewheel();
  ::netput::internal::MouseWheelEvent* mutable_mousewheel();
  void set_allocated_mousewheel(::netput::internal::MouseWheelEvent* value);
  void unsafe_arena_set_allocated_mousewheel(::netput::internal::MouseWheelEvent* value);
  ::netput::internal::MouseWheelEvent* unsafe_arena_release_mousewheel();

  private:
  const ::netput::internal::MouseWheelEvent& _internal_mousewheel() const;
  ::netput::internal::MouseWheelEvent* _internal_mutable_mousewheel();

  public:
  // .netput.internal.KeyboardEvent Keyboard = 6;
  bool has_keyboard() const;
  private:
  bool _internal_has_keyboard() const;

  public:
  void clear_keyboard() ;
  const ::netput::internal::KeyboardEvent& keyboard() const;
  PROTOBUF_NODISCARD ::netput::internal::KeyboardEvent* release_keyboard();
  ::netput::internal::KeyboardEvent* mutable_keyboard();
  void set_allocated_keyboard(::netput::internal::KeyboardEvent* value);
  void unsafe_arena_set_allocated_keyboard(::netput::internal::KeyboardEvent* value);
  ::netput::internal::KeyboardEvent* unsafe_arena_release_keyboard();

  private:
  const ::netput::internal::KeyboardEvent& _internal_keyboard() const;
  ::netput::internal::KeyboardEvent* _internal_mutable_keyboard();

  public:
  // .netput.internal.WindowEvent Window = 7;
  bool has_window() const;
  private:
  bool _internal_has_window() const;

  public:
  void clear_window() ;
  const ::netput::internal::WindowEvent& window() const;
  PROTOBUF_NODISCARD ::netput::internal::WindowEvent* release_window();
  ::netput::internal::WindowEvent* mutable_window();
  void set_allocated_window(::netput::internal::WindowEvent* value);
  void unsafe_arena_set_allocated_window(::netput::internal::WindowEvent* value);
  ::netput::internal::WindowEvent* unsafe_arena_release_window();

  private:
  const ::netput::internal::WindowEvent& _internal_window() const;
  ::netput::internal::WindowEvent* _internal_mutable_window();

  public:
  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:netput.internal.EventRequest)
 private:
  class _Internal;
  void set_has_mousemotion();
  void set_has_mousebutton();
  void set_has_mousewheel();
  void set_has_keyboard();
  void set_has_window();

  inline bool has_Event() const;
  inline void clear_has_Event();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 7, 5,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr sessionid_;
    int type_;
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::netput::internal::MouseMotionEvent* mousemotion_;
      ::netput::internal::MouseButtonEvent* mousebutton_;
      ::netput::internal::MouseWheelEvent* mousewheel_;
      ::netput::internal::KeyboardEvent* keyboard_;
      ::netput::internal::WindowEvent* window_;
    } Event_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_netput_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ConnectRequest

// bytes UserData = 1;
inline void ConnectRequest::clear_userdata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userdata_.ClearToEmpty();
}
inline const std::string& ConnectRequest::userdata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.ConnectRequest.UserData)
  return _internal_userdata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectRequest::set_userdata(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.userdata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:netput.internal.ConnectRequest.UserData)
}
inline std::string* ConnectRequest::mutable_userdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_userdata();
  // @@protoc_insertion_point(field_mutable:netput.internal.ConnectRequest.UserData)
  return _s;
}
inline const std::string& ConnectRequest::_internal_userdata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userdata_.Get();
}
inline void ConnectRequest::_internal_set_userdata(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.userdata_.Set(value, GetArena());
}
inline std::string* ConnectRequest::_internal_mutable_userdata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.userdata_.Mutable( GetArena());
}
inline std::string* ConnectRequest::release_userdata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:netput.internal.ConnectRequest.UserData)
  return _impl_.userdata_.Release();
}
inline void ConnectRequest::set_allocated_userdata(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userdata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userdata_.IsDefault()) {
          _impl_.userdata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:netput.internal.ConnectRequest.UserData)
}

// -------------------------------------------------------------------

// ConnectResponse

// bool success = 1;
inline void ConnectResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ConnectResponse::success() const {
  // @@protoc_insertion_point(field_get:netput.internal.ConnectResponse.success)
  return _internal_success();
}
inline void ConnectResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:netput.internal.ConnectResponse.success)
}
inline bool ConnectResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ConnectResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string SessionID = 2;
inline void ConnectResponse::clear_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& ConnectResponse::sessionid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.ConnectResponse.SessionID)
  return _internal_sessionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectResponse::set_sessionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sessionid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:netput.internal.ConnectResponse.SessionID)
}
inline std::string* ConnectResponse::mutable_sessionid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:netput.internal.ConnectResponse.SessionID)
  return _s;
}
inline const std::string& ConnectResponse::_internal_sessionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sessionid_.Get();
}
inline void ConnectResponse::_internal_set_sessionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sessionid_.Set(value, GetArena());
}
inline std::string* ConnectResponse::_internal_mutable_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sessionid_.Mutable( GetArena());
}
inline std::string* ConnectResponse::release_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:netput.internal.ConnectResponse.SessionID)
  return _impl_.sessionid_.Release();
}
inline void ConnectResponse::set_allocated_sessionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sessionid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sessionid_.IsDefault()) {
          _impl_.sessionid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:netput.internal.ConnectResponse.SessionID)
}

// string Error = 3;
inline void ConnectResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& ConnectResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.ConnectResponse.Error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:netput.internal.ConnectResponse.Error)
}
inline std::string* ConnectResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:netput.internal.ConnectResponse.Error)
  return _s;
}
inline const std::string& ConnectResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void ConnectResponse::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* ConnectResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* ConnectResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:netput.internal.ConnectResponse.Error)
  return _impl_.error_.Release();
}
inline void ConnectResponse::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:netput.internal.ConnectResponse.Error)
}

// -------------------------------------------------------------------

// DisconnectRequest

// string SessionID = 1;
inline void DisconnectRequest::clear_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& DisconnectRequest::sessionid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.DisconnectRequest.SessionID)
  return _internal_sessionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DisconnectRequest::set_sessionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sessionid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:netput.internal.DisconnectRequest.SessionID)
}
inline std::string* DisconnectRequest::mutable_sessionid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:netput.internal.DisconnectRequest.SessionID)
  return _s;
}
inline const std::string& DisconnectRequest::_internal_sessionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sessionid_.Get();
}
inline void DisconnectRequest::_internal_set_sessionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sessionid_.Set(value, GetArena());
}
inline std::string* DisconnectRequest::_internal_mutable_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sessionid_.Mutable( GetArena());
}
inline std::string* DisconnectRequest::release_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:netput.internal.DisconnectRequest.SessionID)
  return _impl_.sessionid_.Release();
}
inline void DisconnectRequest::set_allocated_sessionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sessionid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sessionid_.IsDefault()) {
          _impl_.sessionid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:netput.internal.DisconnectRequest.SessionID)
}

// -------------------------------------------------------------------

// DisconnectResponse

// bool Success = 1;
inline void DisconnectResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool DisconnectResponse::success() const {
  // @@protoc_insertion_point(field_get:netput.internal.DisconnectResponse.Success)
  return _internal_success();
}
inline void DisconnectResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:netput.internal.DisconnectResponse.Success)
}
inline bool DisconnectResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void DisconnectResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string Error = 2;
inline void DisconnectResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& DisconnectResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.DisconnectResponse.Error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DisconnectResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:netput.internal.DisconnectResponse.Error)
}
inline std::string* DisconnectResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:netput.internal.DisconnectResponse.Error)
  return _s;
}
inline const std::string& DisconnectResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void DisconnectResponse::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* DisconnectResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* DisconnectResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:netput.internal.DisconnectResponse.Error)
  return _impl_.error_.Release();
}
inline void DisconnectResponse::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:netput.internal.DisconnectResponse.Error)
}

// -------------------------------------------------------------------

// MouseButtonStateMask

// .netput.internal.MouseState Left = 1;
inline void MouseButtonStateMask::clear_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_ = 0;
}
inline ::netput::internal::MouseState MouseButtonStateMask::left() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonStateMask.Left)
  return _internal_left();
}
inline void MouseButtonStateMask::set_left(::netput::internal::MouseState value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonStateMask.Left)
}
inline ::netput::internal::MouseState MouseButtonStateMask::_internal_left() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::MouseState>(_impl_.left_);
}
inline void MouseButtonStateMask::_internal_set_left(::netput::internal::MouseState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.left_ = value;
}

// .netput.internal.MouseState Middle = 2;
inline void MouseButtonStateMask::clear_middle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.middle_ = 0;
}
inline ::netput::internal::MouseState MouseButtonStateMask::middle() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonStateMask.Middle)
  return _internal_middle();
}
inline void MouseButtonStateMask::set_middle(::netput::internal::MouseState value) {
  _internal_set_middle(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonStateMask.Middle)
}
inline ::netput::internal::MouseState MouseButtonStateMask::_internal_middle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::MouseState>(_impl_.middle_);
}
inline void MouseButtonStateMask::_internal_set_middle(::netput::internal::MouseState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.middle_ = value;
}

// .netput.internal.MouseState Right = 3;
inline void MouseButtonStateMask::clear_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.right_ = 0;
}
inline ::netput::internal::MouseState MouseButtonStateMask::right() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonStateMask.Right)
  return _internal_right();
}
inline void MouseButtonStateMask::set_right(::netput::internal::MouseState value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonStateMask.Right)
}
inline ::netput::internal::MouseState MouseButtonStateMask::_internal_right() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::MouseState>(_impl_.right_);
}
inline void MouseButtonStateMask::_internal_set_right(::netput::internal::MouseState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.right_ = value;
}

// .netput.internal.MouseState X1 = 4;
inline void MouseButtonStateMask::clear_x1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x1_ = 0;
}
inline ::netput::internal::MouseState MouseButtonStateMask::x1() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonStateMask.X1)
  return _internal_x1();
}
inline void MouseButtonStateMask::set_x1(::netput::internal::MouseState value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonStateMask.X1)
}
inline ::netput::internal::MouseState MouseButtonStateMask::_internal_x1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::MouseState>(_impl_.x1_);
}
inline void MouseButtonStateMask::_internal_set_x1(::netput::internal::MouseState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x1_ = value;
}

// .netput.internal.MouseState X2 = 5;
inline void MouseButtonStateMask::clear_x2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x2_ = 0;
}
inline ::netput::internal::MouseState MouseButtonStateMask::x2() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonStateMask.X2)
  return _internal_x2();
}
inline void MouseButtonStateMask::set_x2(::netput::internal::MouseState value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonStateMask.X2)
}
inline ::netput::internal::MouseState MouseButtonStateMask::_internal_x2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::MouseState>(_impl_.x2_);
}
inline void MouseButtonStateMask::_internal_set_x2(::netput::internal::MouseState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x2_ = value;
}

// -------------------------------------------------------------------

// MouseMotionEvent

// uint64 Timestamp = 1;
inline void MouseMotionEvent::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t MouseMotionEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseMotionEvent.Timestamp)
  return _internal_timestamp();
}
inline void MouseMotionEvent::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseMotionEvent.Timestamp)
}
inline ::uint64_t MouseMotionEvent::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void MouseMotionEvent::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// uint32 WindowID = 2;
inline void MouseMotionEvent::clear_windowid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.windowid_ = 0u;
}
inline ::uint32_t MouseMotionEvent::windowid() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseMotionEvent.WindowID)
  return _internal_windowid();
}
inline void MouseMotionEvent::set_windowid(::uint32_t value) {
  _internal_set_windowid(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseMotionEvent.WindowID)
}
inline ::uint32_t MouseMotionEvent::_internal_windowid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowid_;
}
inline void MouseMotionEvent::_internal_set_windowid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.windowid_ = value;
}

// .netput.internal.MouseButtonStateMask StateMask = 3;
inline bool MouseMotionEvent::has_statemask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statemask_ != nullptr);
  return value;
}
inline void MouseMotionEvent::clear_statemask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.statemask_ != nullptr) _impl_.statemask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::netput::internal::MouseButtonStateMask& MouseMotionEvent::_internal_statemask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::netput::internal::MouseButtonStateMask* p = _impl_.statemask_;
  return p != nullptr ? *p : reinterpret_cast<const ::netput::internal::MouseButtonStateMask&>(::netput::internal::_MouseButtonStateMask_default_instance_);
}
inline const ::netput::internal::MouseButtonStateMask& MouseMotionEvent::statemask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.MouseMotionEvent.StateMask)
  return _internal_statemask();
}
inline void MouseMotionEvent::unsafe_arena_set_allocated_statemask(::netput::internal::MouseButtonStateMask* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statemask_);
  }
  _impl_.statemask_ = reinterpret_cast<::netput::internal::MouseButtonStateMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:netput.internal.MouseMotionEvent.StateMask)
}
inline ::netput::internal::MouseButtonStateMask* MouseMotionEvent::release_statemask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::netput::internal::MouseButtonStateMask* released = _impl_.statemask_;
  _impl_.statemask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::netput::internal::MouseButtonStateMask* MouseMotionEvent::unsafe_arena_release_statemask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:netput.internal.MouseMotionEvent.StateMask)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::netput::internal::MouseButtonStateMask* temp = _impl_.statemask_;
  _impl_.statemask_ = nullptr;
  return temp;
}
inline ::netput::internal::MouseButtonStateMask* MouseMotionEvent::_internal_mutable_statemask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.statemask_ == nullptr) {
    auto* p = CreateMaybeMessage<::netput::internal::MouseButtonStateMask>(GetArena());
    _impl_.statemask_ = reinterpret_cast<::netput::internal::MouseButtonStateMask*>(p);
  }
  return _impl_.statemask_;
}
inline ::netput::internal::MouseButtonStateMask* MouseMotionEvent::mutable_statemask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::netput::internal::MouseButtonStateMask* _msg = _internal_mutable_statemask();
  // @@protoc_insertion_point(field_mutable:netput.internal.MouseMotionEvent.StateMask)
  return _msg;
}
inline void MouseMotionEvent::set_allocated_statemask(::netput::internal::MouseButtonStateMask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::netput::internal::MouseButtonStateMask*>(_impl_.statemask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::netput::internal::MouseButtonStateMask*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.statemask_ = reinterpret_cast<::netput::internal::MouseButtonStateMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:netput.internal.MouseMotionEvent.StateMask)
}

// sint32 X = 4;
inline void MouseMotionEvent::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t MouseMotionEvent::x() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseMotionEvent.X)
  return _internal_x();
}
inline void MouseMotionEvent::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseMotionEvent.X)
}
inline ::int32_t MouseMotionEvent::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void MouseMotionEvent::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// sint32 Y = 5;
inline void MouseMotionEvent::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t MouseMotionEvent::y() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseMotionEvent.Y)
  return _internal_y();
}
inline void MouseMotionEvent::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseMotionEvent.Y)
}
inline ::int32_t MouseMotionEvent::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void MouseMotionEvent::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// sint32 RelativeX = 6;
inline void MouseMotionEvent::clear_relativex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relativex_ = 0;
}
inline ::int32_t MouseMotionEvent::relativex() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseMotionEvent.RelativeX)
  return _internal_relativex();
}
inline void MouseMotionEvent::set_relativex(::int32_t value) {
  _internal_set_relativex(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseMotionEvent.RelativeX)
}
inline ::int32_t MouseMotionEvent::_internal_relativex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relativex_;
}
inline void MouseMotionEvent::_internal_set_relativex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.relativex_ = value;
}

// sint32 RelativeY = 7;
inline void MouseMotionEvent::clear_relativey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relativey_ = 0;
}
inline ::int32_t MouseMotionEvent::relativey() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseMotionEvent.RelativeY)
  return _internal_relativey();
}
inline void MouseMotionEvent::set_relativey(::int32_t value) {
  _internal_set_relativey(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseMotionEvent.RelativeY)
}
inline ::int32_t MouseMotionEvent::_internal_relativey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relativey_;
}
inline void MouseMotionEvent::_internal_set_relativey(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.relativey_ = value;
}

// -------------------------------------------------------------------

// MouseButtonEvent

// uint64 Timestamp = 1;
inline void MouseButtonEvent::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t MouseButtonEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonEvent.Timestamp)
  return _internal_timestamp();
}
inline void MouseButtonEvent::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonEvent.Timestamp)
}
inline ::uint64_t MouseButtonEvent::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void MouseButtonEvent::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// uint32 WindowID = 2;
inline void MouseButtonEvent::clear_windowid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.windowid_ = 0u;
}
inline ::uint32_t MouseButtonEvent::windowid() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonEvent.WindowID)
  return _internal_windowid();
}
inline void MouseButtonEvent::set_windowid(::uint32_t value) {
  _internal_set_windowid(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonEvent.WindowID)
}
inline ::uint32_t MouseButtonEvent::_internal_windowid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowid_;
}
inline void MouseButtonEvent::_internal_set_windowid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.windowid_ = value;
}

// .netput.internal.MouseButton Button = 3;
inline void MouseButtonEvent::clear_button() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.button_ = 0;
}
inline ::netput::internal::MouseButton MouseButtonEvent::button() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonEvent.Button)
  return _internal_button();
}
inline void MouseButtonEvent::set_button(::netput::internal::MouseButton value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonEvent.Button)
}
inline ::netput::internal::MouseButton MouseButtonEvent::_internal_button() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::MouseButton>(_impl_.button_);
}
inline void MouseButtonEvent::_internal_set_button(::netput::internal::MouseButton value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.button_ = value;
}

// .netput.internal.MouseState State = 4;
inline void MouseButtonEvent::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::netput::internal::MouseState MouseButtonEvent::state() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonEvent.State)
  return _internal_state();
}
inline void MouseButtonEvent::set_state(::netput::internal::MouseState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonEvent.State)
}
inline ::netput::internal::MouseState MouseButtonEvent::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::MouseState>(_impl_.state_);
}
inline void MouseButtonEvent::_internal_set_state(::netput::internal::MouseState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// bool DoubleClick = 5;
inline void MouseButtonEvent::clear_doubleclick() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doubleclick_ = false;
}
inline bool MouseButtonEvent::doubleclick() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonEvent.DoubleClick)
  return _internal_doubleclick();
}
inline void MouseButtonEvent::set_doubleclick(bool value) {
  _internal_set_doubleclick(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonEvent.DoubleClick)
}
inline bool MouseButtonEvent::_internal_doubleclick() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.doubleclick_;
}
inline void MouseButtonEvent::_internal_set_doubleclick(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.doubleclick_ = value;
}

// sint32 X = 6;
inline void MouseButtonEvent::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t MouseButtonEvent::x() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonEvent.X)
  return _internal_x();
}
inline void MouseButtonEvent::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonEvent.X)
}
inline ::int32_t MouseButtonEvent::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void MouseButtonEvent::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// sint32 Y = 7;
inline void MouseButtonEvent::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t MouseButtonEvent::y() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseButtonEvent.Y)
  return _internal_y();
}
inline void MouseButtonEvent::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseButtonEvent.Y)
}
inline ::int32_t MouseButtonEvent::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void MouseButtonEvent::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// MouseWheelEvent

// uint64 Timestamp = 1;
inline void MouseWheelEvent::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t MouseWheelEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseWheelEvent.Timestamp)
  return _internal_timestamp();
}
inline void MouseWheelEvent::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseWheelEvent.Timestamp)
}
inline ::uint64_t MouseWheelEvent::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void MouseWheelEvent::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// uint32 WindowID = 2;
inline void MouseWheelEvent::clear_windowid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.windowid_ = 0u;
}
inline ::uint32_t MouseWheelEvent::windowid() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseWheelEvent.WindowID)
  return _internal_windowid();
}
inline void MouseWheelEvent::set_windowid(::uint32_t value) {
  _internal_set_windowid(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseWheelEvent.WindowID)
}
inline ::uint32_t MouseWheelEvent::_internal_windowid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowid_;
}
inline void MouseWheelEvent::_internal_set_windowid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.windowid_ = value;
}

// sint32 X = 3;
inline void MouseWheelEvent::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t MouseWheelEvent::x() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseWheelEvent.X)
  return _internal_x();
}
inline void MouseWheelEvent::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseWheelEvent.X)
}
inline ::int32_t MouseWheelEvent::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void MouseWheelEvent::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// sint32 Y = 4;
inline void MouseWheelEvent::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t MouseWheelEvent::y() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseWheelEvent.Y)
  return _internal_y();
}
inline void MouseWheelEvent::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseWheelEvent.Y)
}
inline ::int32_t MouseWheelEvent::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void MouseWheelEvent::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// float PreciseX = 5;
inline void MouseWheelEvent::clear_precisex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.precisex_ = 0;
}
inline float MouseWheelEvent::precisex() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseWheelEvent.PreciseX)
  return _internal_precisex();
}
inline void MouseWheelEvent::set_precisex(float value) {
  _internal_set_precisex(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseWheelEvent.PreciseX)
}
inline float MouseWheelEvent::_internal_precisex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.precisex_;
}
inline void MouseWheelEvent::_internal_set_precisex(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.precisex_ = value;
}

// float PreciceY = 6;
inline void MouseWheelEvent::clear_precicey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.precicey_ = 0;
}
inline float MouseWheelEvent::precicey() const {
  // @@protoc_insertion_point(field_get:netput.internal.MouseWheelEvent.PreciceY)
  return _internal_precicey();
}
inline void MouseWheelEvent::set_precicey(float value) {
  _internal_set_precicey(value);
  // @@protoc_insertion_point(field_set:netput.internal.MouseWheelEvent.PreciceY)
}
inline float MouseWheelEvent::_internal_precicey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.precicey_;
}
inline void MouseWheelEvent::_internal_set_precicey(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.precicey_ = value;
}

// -------------------------------------------------------------------

// KeyboardEvent

// uint64 Timestamp = 1;
inline void KeyboardEvent::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t KeyboardEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:netput.internal.KeyboardEvent.Timestamp)
  return _internal_timestamp();
}
inline void KeyboardEvent::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:netput.internal.KeyboardEvent.Timestamp)
}
inline ::uint64_t KeyboardEvent::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void KeyboardEvent::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// uint32 WindowID = 2;
inline void KeyboardEvent::clear_windowid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.windowid_ = 0u;
}
inline ::uint32_t KeyboardEvent::windowid() const {
  // @@protoc_insertion_point(field_get:netput.internal.KeyboardEvent.WindowID)
  return _internal_windowid();
}
inline void KeyboardEvent::set_windowid(::uint32_t value) {
  _internal_set_windowid(value);
  // @@protoc_insertion_point(field_set:netput.internal.KeyboardEvent.WindowID)
}
inline ::uint32_t KeyboardEvent::_internal_windowid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowid_;
}
inline void KeyboardEvent::_internal_set_windowid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.windowid_ = value;
}

// .netput.internal.KeyState State = 3;
inline void KeyboardEvent::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::netput::internal::KeyState KeyboardEvent::state() const {
  // @@protoc_insertion_point(field_get:netput.internal.KeyboardEvent.State)
  return _internal_state();
}
inline void KeyboardEvent::set_state(::netput::internal::KeyState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:netput.internal.KeyboardEvent.State)
}
inline ::netput::internal::KeyState KeyboardEvent::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::KeyState>(_impl_.state_);
}
inline void KeyboardEvent::_internal_set_state(::netput::internal::KeyState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// bool Repeat = 4;
inline void KeyboardEvent::clear_repeat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repeat_ = false;
}
inline bool KeyboardEvent::repeat() const {
  // @@protoc_insertion_point(field_get:netput.internal.KeyboardEvent.Repeat)
  return _internal_repeat();
}
inline void KeyboardEvent::set_repeat(bool value) {
  _internal_set_repeat(value);
  // @@protoc_insertion_point(field_set:netput.internal.KeyboardEvent.Repeat)
}
inline bool KeyboardEvent::_internal_repeat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repeat_;
}
inline void KeyboardEvent::_internal_set_repeat(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.repeat_ = value;
}

// uint32 KeyCode = 5;
inline void KeyboardEvent::clear_keycode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keycode_ = 0u;
}
inline ::uint32_t KeyboardEvent::keycode() const {
  // @@protoc_insertion_point(field_get:netput.internal.KeyboardEvent.KeyCode)
  return _internal_keycode();
}
inline void KeyboardEvent::set_keycode(::uint32_t value) {
  _internal_set_keycode(value);
  // @@protoc_insertion_point(field_set:netput.internal.KeyboardEvent.KeyCode)
}
inline ::uint32_t KeyboardEvent::_internal_keycode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keycode_;
}
inline void KeyboardEvent::_internal_set_keycode(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keycode_ = value;
}

// -------------------------------------------------------------------

// WindowEvent

// uint64 Timestamp = 1;
inline void WindowEvent::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t WindowEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:netput.internal.WindowEvent.Timestamp)
  return _internal_timestamp();
}
inline void WindowEvent::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:netput.internal.WindowEvent.Timestamp)
}
inline ::uint64_t WindowEvent::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void WindowEvent::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// uint32 WindowID = 2;
inline void WindowEvent::clear_windowid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.windowid_ = 0u;
}
inline ::uint32_t WindowEvent::windowid() const {
  // @@protoc_insertion_point(field_get:netput.internal.WindowEvent.WindowID)
  return _internal_windowid();
}
inline void WindowEvent::set_windowid(::uint32_t value) {
  _internal_set_windowid(value);
  // @@protoc_insertion_point(field_set:netput.internal.WindowEvent.WindowID)
}
inline ::uint32_t WindowEvent::_internal_windowid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.windowid_;
}
inline void WindowEvent::_internal_set_windowid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.windowid_ = value;
}

// .netput.internal.WindowEventType Type = 3;
inline void WindowEvent::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::netput::internal::WindowEventType WindowEvent::type() const {
  // @@protoc_insertion_point(field_get:netput.internal.WindowEvent.Type)
  return _internal_type();
}
inline void WindowEvent::set_type(::netput::internal::WindowEventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:netput.internal.WindowEvent.Type)
}
inline ::netput::internal::WindowEventType WindowEvent::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::WindowEventType>(_impl_.type_);
}
inline void WindowEvent::_internal_set_type(::netput::internal::WindowEventType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// sint32 Arg1 = 4;
inline void WindowEvent::clear_arg1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arg1_ = 0;
}
inline ::int32_t WindowEvent::arg1() const {
  // @@protoc_insertion_point(field_get:netput.internal.WindowEvent.Arg1)
  return _internal_arg1();
}
inline void WindowEvent::set_arg1(::int32_t value) {
  _internal_set_arg1(value);
  // @@protoc_insertion_point(field_set:netput.internal.WindowEvent.Arg1)
}
inline ::int32_t WindowEvent::_internal_arg1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arg1_;
}
inline void WindowEvent::_internal_set_arg1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arg1_ = value;
}

// sint32 Arg2 = 5;
inline void WindowEvent::clear_arg2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arg2_ = 0;
}
inline ::int32_t WindowEvent::arg2() const {
  // @@protoc_insertion_point(field_get:netput.internal.WindowEvent.Arg2)
  return _internal_arg2();
}
inline void WindowEvent::set_arg2(::int32_t value) {
  _internal_set_arg2(value);
  // @@protoc_insertion_point(field_set:netput.internal.WindowEvent.Arg2)
}
inline ::int32_t WindowEvent::_internal_arg2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arg2_;
}
inline void WindowEvent::_internal_set_arg2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arg2_ = value;
}

// -------------------------------------------------------------------

// EventRequest

// string SessionID = 1;
inline void EventRequest::clear_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& EventRequest::sessionid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.EventRequest.SessionID)
  return _internal_sessionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventRequest::set_sessionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sessionid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:netput.internal.EventRequest.SessionID)
}
inline std::string* EventRequest::mutable_sessionid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:netput.internal.EventRequest.SessionID)
  return _s;
}
inline const std::string& EventRequest::_internal_sessionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sessionid_.Get();
}
inline void EventRequest::_internal_set_sessionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sessionid_.Set(value, GetArena());
}
inline std::string* EventRequest::_internal_mutable_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sessionid_.Mutable( GetArena());
}
inline std::string* EventRequest::release_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:netput.internal.EventRequest.SessionID)
  return _impl_.sessionid_.Release();
}
inline void EventRequest::set_allocated_sessionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sessionid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sessionid_.IsDefault()) {
          _impl_.sessionid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:netput.internal.EventRequest.SessionID)
}

// .netput.internal.EventType Type = 2;
inline void EventRequest::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::netput::internal::EventType EventRequest::type() const {
  // @@protoc_insertion_point(field_get:netput.internal.EventRequest.Type)
  return _internal_type();
}
inline void EventRequest::set_type(::netput::internal::EventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:netput.internal.EventRequest.Type)
}
inline ::netput::internal::EventType EventRequest::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::netput::internal::EventType>(_impl_.type_);
}
inline void EventRequest::_internal_set_type(::netput::internal::EventType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .netput.internal.MouseMotionEvent MouseMotion = 3;
inline bool EventRequest::has_mousemotion() const {
  return Event_case() == kMouseMotion;
}
inline bool EventRequest::_internal_has_mousemotion() const {
  return Event_case() == kMouseMotion;
}
inline void EventRequest::set_has_mousemotion() {
  _impl_._oneof_case_[0] = kMouseMotion;
}
inline void EventRequest::clear_mousemotion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Event_case() == kMouseMotion) {
    if (GetArena() == nullptr) {
      delete _impl_.Event_.mousemotion_;
    }
    clear_has_Event();
  }
}
inline ::netput::internal::MouseMotionEvent* EventRequest::release_mousemotion() {
  // @@protoc_insertion_point(field_release:netput.internal.EventRequest.MouseMotion)
  if (Event_case() == kMouseMotion) {
    clear_has_Event();
    auto* temp = _impl_.Event_.mousemotion_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Event_.mousemotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::netput::internal::MouseMotionEvent& EventRequest::_internal_mousemotion() const {
  return Event_case() == kMouseMotion ? *_impl_.Event_.mousemotion_ : reinterpret_cast<::netput::internal::MouseMotionEvent&>(::netput::internal::_MouseMotionEvent_default_instance_);
}
inline const ::netput::internal::MouseMotionEvent& EventRequest::mousemotion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.EventRequest.MouseMotion)
  return _internal_mousemotion();
}
inline ::netput::internal::MouseMotionEvent* EventRequest::unsafe_arena_release_mousemotion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:netput.internal.EventRequest.MouseMotion)
  if (Event_case() == kMouseMotion) {
    clear_has_Event();
    auto* temp = _impl_.Event_.mousemotion_;
    _impl_.Event_.mousemotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventRequest::unsafe_arena_set_allocated_mousemotion(::netput::internal::MouseMotionEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_Event();
  if (value) {
    set_has_mousemotion();
    _impl_.Event_.mousemotion_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:netput.internal.EventRequest.MouseMotion)
}
inline ::netput::internal::MouseMotionEvent* EventRequest::_internal_mutable_mousemotion() {
  if (Event_case() != kMouseMotion) {
    clear_Event();
    set_has_mousemotion();
    _impl_.Event_.mousemotion_ = CreateMaybeMessage<::netput::internal::MouseMotionEvent>(GetArena());
  }
  return _impl_.Event_.mousemotion_;
}
inline ::netput::internal::MouseMotionEvent* EventRequest::mutable_mousemotion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::netput::internal::MouseMotionEvent* _msg = _internal_mutable_mousemotion();
  // @@protoc_insertion_point(field_mutable:netput.internal.EventRequest.MouseMotion)
  return _msg;
}

// .netput.internal.MouseButtonEvent MouseButton = 4;
inline bool EventRequest::has_mousebutton() const {
  return Event_case() == kMouseButton;
}
inline bool EventRequest::_internal_has_mousebutton() const {
  return Event_case() == kMouseButton;
}
inline void EventRequest::set_has_mousebutton() {
  _impl_._oneof_case_[0] = kMouseButton;
}
inline void EventRequest::clear_mousebutton() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Event_case() == kMouseButton) {
    if (GetArena() == nullptr) {
      delete _impl_.Event_.mousebutton_;
    }
    clear_has_Event();
  }
}
inline ::netput::internal::MouseButtonEvent* EventRequest::release_mousebutton() {
  // @@protoc_insertion_point(field_release:netput.internal.EventRequest.MouseButton)
  if (Event_case() == kMouseButton) {
    clear_has_Event();
    auto* temp = _impl_.Event_.mousebutton_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Event_.mousebutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::netput::internal::MouseButtonEvent& EventRequest::_internal_mousebutton() const {
  return Event_case() == kMouseButton ? *_impl_.Event_.mousebutton_ : reinterpret_cast<::netput::internal::MouseButtonEvent&>(::netput::internal::_MouseButtonEvent_default_instance_);
}
inline const ::netput::internal::MouseButtonEvent& EventRequest::mousebutton() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.EventRequest.MouseButton)
  return _internal_mousebutton();
}
inline ::netput::internal::MouseButtonEvent* EventRequest::unsafe_arena_release_mousebutton() {
  // @@protoc_insertion_point(field_unsafe_arena_release:netput.internal.EventRequest.MouseButton)
  if (Event_case() == kMouseButton) {
    clear_has_Event();
    auto* temp = _impl_.Event_.mousebutton_;
    _impl_.Event_.mousebutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventRequest::unsafe_arena_set_allocated_mousebutton(::netput::internal::MouseButtonEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_Event();
  if (value) {
    set_has_mousebutton();
    _impl_.Event_.mousebutton_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:netput.internal.EventRequest.MouseButton)
}
inline ::netput::internal::MouseButtonEvent* EventRequest::_internal_mutable_mousebutton() {
  if (Event_case() != kMouseButton) {
    clear_Event();
    set_has_mousebutton();
    _impl_.Event_.mousebutton_ = CreateMaybeMessage<::netput::internal::MouseButtonEvent>(GetArena());
  }
  return _impl_.Event_.mousebutton_;
}
inline ::netput::internal::MouseButtonEvent* EventRequest::mutable_mousebutton() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::netput::internal::MouseButtonEvent* _msg = _internal_mutable_mousebutton();
  // @@protoc_insertion_point(field_mutable:netput.internal.EventRequest.MouseButton)
  return _msg;
}

// .netput.internal.MouseWheelEvent MouseWheel = 5;
inline bool EventRequest::has_mousewheel() const {
  return Event_case() == kMouseWheel;
}
inline bool EventRequest::_internal_has_mousewheel() const {
  return Event_case() == kMouseWheel;
}
inline void EventRequest::set_has_mousewheel() {
  _impl_._oneof_case_[0] = kMouseWheel;
}
inline void EventRequest::clear_mousewheel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Event_case() == kMouseWheel) {
    if (GetArena() == nullptr) {
      delete _impl_.Event_.mousewheel_;
    }
    clear_has_Event();
  }
}
inline ::netput::internal::MouseWheelEvent* EventRequest::release_mousewheel() {
  // @@protoc_insertion_point(field_release:netput.internal.EventRequest.MouseWheel)
  if (Event_case() == kMouseWheel) {
    clear_has_Event();
    auto* temp = _impl_.Event_.mousewheel_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Event_.mousewheel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::netput::internal::MouseWheelEvent& EventRequest::_internal_mousewheel() const {
  return Event_case() == kMouseWheel ? *_impl_.Event_.mousewheel_ : reinterpret_cast<::netput::internal::MouseWheelEvent&>(::netput::internal::_MouseWheelEvent_default_instance_);
}
inline const ::netput::internal::MouseWheelEvent& EventRequest::mousewheel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.EventRequest.MouseWheel)
  return _internal_mousewheel();
}
inline ::netput::internal::MouseWheelEvent* EventRequest::unsafe_arena_release_mousewheel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:netput.internal.EventRequest.MouseWheel)
  if (Event_case() == kMouseWheel) {
    clear_has_Event();
    auto* temp = _impl_.Event_.mousewheel_;
    _impl_.Event_.mousewheel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventRequest::unsafe_arena_set_allocated_mousewheel(::netput::internal::MouseWheelEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_Event();
  if (value) {
    set_has_mousewheel();
    _impl_.Event_.mousewheel_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:netput.internal.EventRequest.MouseWheel)
}
inline ::netput::internal::MouseWheelEvent* EventRequest::_internal_mutable_mousewheel() {
  if (Event_case() != kMouseWheel) {
    clear_Event();
    set_has_mousewheel();
    _impl_.Event_.mousewheel_ = CreateMaybeMessage<::netput::internal::MouseWheelEvent>(GetArena());
  }
  return _impl_.Event_.mousewheel_;
}
inline ::netput::internal::MouseWheelEvent* EventRequest::mutable_mousewheel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::netput::internal::MouseWheelEvent* _msg = _internal_mutable_mousewheel();
  // @@protoc_insertion_point(field_mutable:netput.internal.EventRequest.MouseWheel)
  return _msg;
}

// .netput.internal.KeyboardEvent Keyboard = 6;
inline bool EventRequest::has_keyboard() const {
  return Event_case() == kKeyboard;
}
inline bool EventRequest::_internal_has_keyboard() const {
  return Event_case() == kKeyboard;
}
inline void EventRequest::set_has_keyboard() {
  _impl_._oneof_case_[0] = kKeyboard;
}
inline void EventRequest::clear_keyboard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Event_case() == kKeyboard) {
    if (GetArena() == nullptr) {
      delete _impl_.Event_.keyboard_;
    }
    clear_has_Event();
  }
}
inline ::netput::internal::KeyboardEvent* EventRequest::release_keyboard() {
  // @@protoc_insertion_point(field_release:netput.internal.EventRequest.Keyboard)
  if (Event_case() == kKeyboard) {
    clear_has_Event();
    auto* temp = _impl_.Event_.keyboard_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Event_.keyboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::netput::internal::KeyboardEvent& EventRequest::_internal_keyboard() const {
  return Event_case() == kKeyboard ? *_impl_.Event_.keyboard_ : reinterpret_cast<::netput::internal::KeyboardEvent&>(::netput::internal::_KeyboardEvent_default_instance_);
}
inline const ::netput::internal::KeyboardEvent& EventRequest::keyboard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.EventRequest.Keyboard)
  return _internal_keyboard();
}
inline ::netput::internal::KeyboardEvent* EventRequest::unsafe_arena_release_keyboard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:netput.internal.EventRequest.Keyboard)
  if (Event_case() == kKeyboard) {
    clear_has_Event();
    auto* temp = _impl_.Event_.keyboard_;
    _impl_.Event_.keyboard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventRequest::unsafe_arena_set_allocated_keyboard(::netput::internal::KeyboardEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_Event();
  if (value) {
    set_has_keyboard();
    _impl_.Event_.keyboard_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:netput.internal.EventRequest.Keyboard)
}
inline ::netput::internal::KeyboardEvent* EventRequest::_internal_mutable_keyboard() {
  if (Event_case() != kKeyboard) {
    clear_Event();
    set_has_keyboard();
    _impl_.Event_.keyboard_ = CreateMaybeMessage<::netput::internal::KeyboardEvent>(GetArena());
  }
  return _impl_.Event_.keyboard_;
}
inline ::netput::internal::KeyboardEvent* EventRequest::mutable_keyboard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::netput::internal::KeyboardEvent* _msg = _internal_mutable_keyboard();
  // @@protoc_insertion_point(field_mutable:netput.internal.EventRequest.Keyboard)
  return _msg;
}

// .netput.internal.WindowEvent Window = 7;
inline bool EventRequest::has_window() const {
  return Event_case() == kWindow;
}
inline bool EventRequest::_internal_has_window() const {
  return Event_case() == kWindow;
}
inline void EventRequest::set_has_window() {
  _impl_._oneof_case_[0] = kWindow;
}
inline void EventRequest::clear_window() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Event_case() == kWindow) {
    if (GetArena() == nullptr) {
      delete _impl_.Event_.window_;
    }
    clear_has_Event();
  }
}
inline ::netput::internal::WindowEvent* EventRequest::release_window() {
  // @@protoc_insertion_point(field_release:netput.internal.EventRequest.Window)
  if (Event_case() == kWindow) {
    clear_has_Event();
    auto* temp = _impl_.Event_.window_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Event_.window_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::netput::internal::WindowEvent& EventRequest::_internal_window() const {
  return Event_case() == kWindow ? *_impl_.Event_.window_ : reinterpret_cast<::netput::internal::WindowEvent&>(::netput::internal::_WindowEvent_default_instance_);
}
inline const ::netput::internal::WindowEvent& EventRequest::window() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.EventRequest.Window)
  return _internal_window();
}
inline ::netput::internal::WindowEvent* EventRequest::unsafe_arena_release_window() {
  // @@protoc_insertion_point(field_unsafe_arena_release:netput.internal.EventRequest.Window)
  if (Event_case() == kWindow) {
    clear_has_Event();
    auto* temp = _impl_.Event_.window_;
    _impl_.Event_.window_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventRequest::unsafe_arena_set_allocated_window(::netput::internal::WindowEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_Event();
  if (value) {
    set_has_window();
    _impl_.Event_.window_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:netput.internal.EventRequest.Window)
}
inline ::netput::internal::WindowEvent* EventRequest::_internal_mutable_window() {
  if (Event_case() != kWindow) {
    clear_Event();
    set_has_window();
    _impl_.Event_.window_ = CreateMaybeMessage<::netput::internal::WindowEvent>(GetArena());
  }
  return _impl_.Event_.window_;
}
inline ::netput::internal::WindowEvent* EventRequest::mutable_window() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::netput::internal::WindowEvent* _msg = _internal_mutable_window();
  // @@protoc_insertion_point(field_mutable:netput.internal.EventRequest.Window)
  return _msg;
}

inline bool EventRequest::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void EventRequest::clear_has_Event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline EventRequest::EventCase EventRequest::Event_case() const {
  return EventRequest::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EventResponse

// bool Success = 1;
inline void EventResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool EventResponse::success() const {
  // @@protoc_insertion_point(field_get:netput.internal.EventResponse.Success)
  return _internal_success();
}
inline void EventResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:netput.internal.EventResponse.Success)
}
inline bool EventResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void EventResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string Error = 2;
inline void EventResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.ClearToEmpty();
}
inline const std::string& EventResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:netput.internal.EventResponse.Error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:netput.internal.EventResponse.Error)
}
inline std::string* EventResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:netput.internal.EventResponse.Error)
  return _s;
}
inline const std::string& EventResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_.Get();
}
inline void EventResponse::_internal_set_error(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* EventResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* EventResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:netput.internal.EventResponse.Error)
  return _impl_.error_.Release();
}
inline void EventResponse::set_allocated_error(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:netput.internal.EventResponse.Error)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace internal
}  // namespace netput


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::netput::internal::EventType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::netput::internal::EventType>() {
  return ::netput::internal::EventType_descriptor();
}
template <>
struct is_proto_enum<::netput::internal::KeyState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::netput::internal::KeyState>() {
  return ::netput::internal::KeyState_descriptor();
}
template <>
struct is_proto_enum<::netput::internal::MouseButton> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::netput::internal::MouseButton>() {
  return ::netput::internal::MouseButton_descriptor();
}
template <>
struct is_proto_enum<::netput::internal::MouseState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::netput::internal::MouseState>() {
  return ::netput::internal::MouseState_descriptor();
}
template <>
struct is_proto_enum<::netput::internal::WindowEventType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::netput::internal::WindowEventType>() {
  return ::netput::internal::WindowEventType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_netput_2eproto_2epb_2eh
